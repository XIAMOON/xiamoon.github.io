<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:type" content="website">
<meta property="og:title" content="李乾的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="李乾的博客">
<meta property="og:description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李乾的博客">
<meta name="twitter:description" content="人生不止眼前的苟且 还有诗和远方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>李乾的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李乾的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海攻城狮一枚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/（三）《LearnOpenGL-CN》-你好窗口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/（三）《LearnOpenGL-CN》-你好窗口/" itemprop="url">（三）《LearnOpenGL CN》-- 你好窗口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T00:00:00+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-双缓冲-Double-Buffer"><a href="#1-双缓冲-Double-Buffer" class="headerlink" title="1. 双缓冲(Double Buffer)"></a>1. 双缓冲(Double Buffer)</h4><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。<br><br></p>
<ol start="2">
<li>你应该能够回忆起来我们在 OpenGL 这节教程的内容，glClearColor函数是一个状态设置函数，而glClear函数则是一个状态使用的函数，它使用了当前的状态来获取应该清除为的颜色。</li>
</ol>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p><a href="/source/learnOpenGL3_sample.zip">代码下载</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/（二）《LearnOpenGL-CN》–-创建窗口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/（二）《LearnOpenGL-CN》–-创建窗口/" itemprop="url">（二）《LearnOpenGL CN》– 创建窗口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T15:36:45+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文-Context-和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象-Abstract-出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。"><a href="#1-在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文-Context-和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象-Abstract-出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。" class="headerlink" title="1. 在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。"></a>1. 在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/读《LearnOpenGL-CN》-OpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/读《LearnOpenGL-CN》-OpenGL/" itemprop="url">读《LearnOpenGL CN》-- OpenGL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T00:00:00+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范-Specification-。"><a href="#1-OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范-Specification-。" class="headerlink" title="1. OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。"></a>1. OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。</h4><p><br></p>
<h4 id="2-OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现-Implement-的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。"><a href="#2-OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现-Implement-的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。" class="headerlink" title="2. OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。"></a>2. OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。</h4><p><br></p>
<h4 id="3-实际的OpenGL库的开发者通常是显卡的生产商。"><a href="#3-实际的OpenGL库的开发者通常是显卡的生产商。" class="headerlink" title="3. 实际的OpenGL库的开发者通常是显卡的生产商。"></a>3. 实际的OpenGL库的开发者通常是显卡的生产商。</h4><p><br></p>
<h4 id="4-OpenGL自身是一个巨大的状态机-State-Machine-：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文-Context-。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。"><a href="#4-OpenGL自身是一个巨大的状态机-State-Machine-：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文-Context-。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。" class="headerlink" title="4. OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。"></a>4. OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</h4><p>只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。<br><br></p>
<h4 id="5-OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。"><a href="#5-OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。" class="headerlink" title="5. OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。"></a>5. OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。</h4><p><br></p>
<h4 id="6-在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体-Struct-："><a href="#6-在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体-Struct-：" class="headerlink" title="6. 在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)："></a>6. 在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> object_name &#123;</span><br><span class="line"><span class="keyword">float</span>  option1;</span><br><span class="line"><span class="keyword">int</span>    option2;</span><br><span class="line"><span class="keyword">char</span>[] name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="7-常见工作流："><a href="#7-常见工作流：" class="headerlink" title="7. 常见工作流："></a>7. 常见工作流：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。<br>objectId就类似于我们OC中的一个对象名，都是保存着对象的引用。以后要想访问这个对象，用objectId就可以访问。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/一-转场动画-初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/一-转场动画-初探/" itemprop="url">(一)转场动画-初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T00:00:00+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、系统跳转原理详解"><a href="#一、系统跳转原理详解" class="headerlink" title="一、系统跳转原理详解"></a>一、系统跳转原理详解</h3><p>所谓的控制器跳转大家都知道，导航控制器使用push，而一般控制器跳转用present。一般如果不自定义跳转动画的话，一句代码就可以搞定跳转：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<p>当需要自定义控制器跳转时，这里假定是fromVC跳转到toVC，对应视图是fromView和toView，首先要知道是这个动画是怎么产生的。</p>
<p>在系统帮我们实现的跳转中，当发生跳转时，视图层次中会增加一个<code>containerView</code>（在视图层次中叫做<code>UITransitionView</code>），这个视图颜色是透明的，所以是看不到的。当发生跳转时，toView被加入到containerView中，frame是[[0, screenHeight], [screenWidth, screenHeight]]，然后发生一个大约0.3秒的动画，使toView在0.3秒内从页面底部移动到顶部，frame为[[0, 0], [screenWidth, screenHeight]]。当跳转发生后，containerView是一直存在的。跳转完毕后，fromVC将暂时从视图层次中移除，而toVC将一直存在于视图层次中。toView将一直作为containerView的子视图存在。</p>
<p>假设此时toVC再次跳转到toVC2，那么第一个containerView还是存在，但是其子视图toView将被移除。视图层次中增加<code>containerView2</code>，其子视图为toView2。toVC被从视图层次中移除。</p>
<p>如果此时toVC2<code>dismiss</code>了。那么containerView2及其子视图toView2从视图层次中移除，toVC2自然也被移除。<code>containerView</code>的子视图toView又被添加为其子视图。</p>
<blockquote>
<p>从上面可以知道：每次跳转时，都会有一个containerView作为跳转动画的发生“场所”<br>只有跳转完成后，fromVC才会从视图层次中消失。</p>
</blockquote>
<h3 id="二、自定义跳转构思"><a href="#二、自定义跳转构思" class="headerlink" title="二、自定义跳转构思"></a>二、自定义跳转构思</h3><p>只要自定义containerView的子视图层次，然后定义其动画效果就可以自己实现转场动画了。</p>
<h3 id="三、系统提供的API"><a href="#三、系统提供的API" class="headerlink" title="三、系统提供的API"></a>三、系统提供的API</h3><p>查看UIViewController的API，可以看到这样一个分类：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerTransitioningDelegate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span>(<span class="title">UIViewControllerTransitioning</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitioningDelegate</span>&gt; transitioningDelegate <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这个是专门用来自定义专场动画的代理。一般来说，需要给toVC的<code>transitioningDelegate</code>设置代理，fromVC是不需要设置代理的。</p>
<p>当发生跳转时，系统会检测toVC的<code>transitioningDelegate</code>是否为空，如果不为空，那么就会用它的代理来实现各种转场效果。当然这些转场效果当然是自己定义的。</p>
<p>我们先来看看<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>协议里有哪些方法需要实现：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UIPresentationController</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerTransitioningDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 1.present时的动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.dismiss时的动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.present时的交互</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.dismiss时的交互</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5....</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting sourceViewController:(<span class="built_in">UIViewController</span> *)source <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>一般来说，定义一个简单的专场动画，只需要实现前两个协议即可。前两个协议都是需要提供一个遵循了<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code>协议的类。所以<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code>才是自定义转场动画的地方。</p>
<p>下面来看重点–<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code>协议：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerAnimatedTransitioning</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used for percent driven interactive transitions, as well as for</span></span><br><span class="line"><span class="comment">// container controllers that have companion animations that might need to</span></span><br><span class="line"><span class="comment">// synchronize with the main animation.</span></span><br><span class="line"><span class="comment">// 1.提供动画时间</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</span><br><span class="line"><span class="comment">// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</span></span><br><span class="line"><span class="comment">// 2.自定义转场动画</span></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A conforming object implements this method if the transition it creates can</span></span><br><span class="line"><span class="comment">/// be interrupted. For example, it could return an instance of a</span></span><br><span class="line"><span class="comment">/// UIViewPropertyAnimator. It is expected that this method will return the same</span></span><br><span class="line"><span class="comment">/// instance for the life of a transition.</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">UIViewImplicitlyAnimating</span>&gt;) interruptibleAnimatorForTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a convenience and if implemented will be invoked by the system when the transition context's completeTransition: method is invoked.</span></span><br><span class="line"><span class="comment">// 4.如果实现了，将会被系统调用</span></span><br><span class="line">- (<span class="keyword">void</span>)animationEnded:(<span class="built_in">BOOL</span>) transitionCompleted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>一般来说，实现前两个就可以自定义专场动画了。<br>下面来实现一个简单的弹簧效果的转场动画。</p>
<p>#####四、实现简单的专场动画<br>先自定义一个类：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BouncePresentAnimation</span> : <span class="title">NSObject</span>&lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>.m文件中实现2个协议方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line"><span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line"><span class="built_in">CGRect</span> finalFrame = [transitionContext finalFrameForViewController:toVC];</span><br><span class="line"><span class="built_in">CGRect</span> screenBounds = [[<span class="built_in">UIScreen</span> mainScreen] bounds];    </span><br><span class="line">toVC.view.frame = <span class="built_in">CGRectOffset</span>(finalFrame, <span class="number">0</span>, screenBounds.size.height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *containerView = [transitionContext containerView];</span><br><span class="line">[containerView addSubview:toVC.view]; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSTimeInterval</span> duration = [<span class="keyword">self</span> transitionDuration:transitionContext];</span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:duration delay:<span class="number">0.0</span> usingSpringWithDamping:<span class="number">0.6</span> initialSpringVelocity:<span class="number">0.0</span> options:<span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">toVC.view.frame = <span class="built_in">CGRectOffset</span>(finalFrame, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// 这一句代码是必须的，只有编辑为complete时，页面才能继续交互。</span></span><br><span class="line"><span class="comment">// 当调用这一句代码之后，fromVc就不在页面层次里了，所以背景一般会变黑。</span></span><br><span class="line">[transitionContext completeTransition:<span class="literal">YES</span>]; <span class="comment">// 2</span></span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>在发生跳转时，<code>containerView</code>立马被添加到视图层次中，我们所能看到的一切动画都是发生在<code>containerView</code>中的。<code>containerView</code>的背景颜色是透明的。<br>在自定义转场动画时，<code>containerView</code>里面是没有任何视图的。所以，在跳转时我们所看到的跳转视图动画都是我们自己添加到<code>containerView</code>中去的。<br>1处的代码是把toView添加到<code>containerView</code>中。操作这个toView，就能看到转场动画。<br>[transitionContext completeTransition:YES]可以在任何时候去调用。但是一旦调用后，fromView立马就被从视图层次中移除了，所以会看到黑色的背景。<br>2处的代码是在动画结束后调用的，所以在动画发生过程中是不会看到黑色背景的，因为此时fromView并未从视图层次中移除，而且<code>containerView</code>背景又是透明的，所以此时看到的背景依然是fromView。</p>
</blockquote>
<p>同样dismiss动画也可以自定义转场动画：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line"><span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line"><span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGRect</span> initialFrame = [transitionContext initialFrameForViewController:fromVC];</span><br><span class="line"><span class="built_in">CGRect</span> screenBounds = [<span class="built_in">UIScreen</span> mainScreen].bounds;</span><br><span class="line"><span class="built_in">CGRect</span> finalFrame = <span class="built_in">CGRectOffset</span>(initialFrame, <span class="number">0</span>, screenBounds.size.height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *containerView = [transitionContext containerView]; <span class="comment">//1</span></span><br><span class="line">[containerView insertSubview:toVC.view atIndex:<span class="number">0</span>]; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> delay:<span class="number">0.0</span> usingSpringWithDamping:<span class="number">0.6</span> initialSpringVelocity:<span class="number">0.6</span> options:<span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">fromVC.view.frame = finalFrame;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">[transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>此时的fromVC是之前present时的toVC。在dismiss时，from和to跟之前都是相反的。<br>此时<code>containerView</code>中包含fromView。如果不加1和2处的代码，那么在dismiss过程中，背景是黑色的，只有动画完成后，页面才看起来正常。这是因为，动画过程中我们只能看到<code>containerView</code>，如果只有fromView，那么，背景自然是黑色的。所以，为了使动画看起来正常，先把toView添加到<code>containerView</code>的最下面一层。</p>
</blockquote>
<p>项目：<a href="/source/summary_transaction_sample_1.zip">代码下载</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/三、Core-Graphics-Graphics-Contexts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/三、Core-Graphics-Graphics-Contexts/" itemprop="url">三、Core Graphics - Graphics Contexts</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T00:00:00+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Core Graphics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>图形上下文表示绘图目标。 它包含绘图参数和绘图系统需要执行任何后续绘图命令的所有特定于设备的信息。 图形上下文定义了基本绘图属性，例如绘制时使用的颜色，裁剪区域，线宽和样式信息，字体信息，合成选项等。</p>
<p>您可以通过使用Quartz上下文创建功能或通过使用其中一个Mac OS X框架或iOS中的UIKit框架提供的更高级别的功能来获取图形上下文。 Quartz提供各种Quartz图形上下文的功能，包括位图和PDF，可用于创建自定义内容。</p>
<p>本章介绍如何为各种绘图目标创建图形上下文。 图形上下文通过数据类型CGContextRef（它是不透明数据类型）在代码中表示。 获取图形上下文后，您可以使用Quartz 2D函数绘制上下文，在上下文中执行操作（如转换），并更改图形状态参数，例如线宽和填充颜色。</p>
<h3 id="在iOS中绘制视图图形上下文"><a href="#在iOS中绘制视图图形上下文" class="headerlink" title="在iOS中绘制视图图形上下文"></a>在iOS中绘制视图图形上下文</h3><p>要在iOS应用程序中绘制屏幕，您可以设置一个<a href="https://developer.apple.com/documentation/uikit/uiview" target="_blank" rel="noopener">UIView</a>对象并实现其<a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect" target="_blank" rel="noopener">drawRect:</a>方法来执行绘图。 当视图在屏幕上可见并且其内容需要更新时，视图的<code>drawRect:</code>方法将会被调用。 在调用自定义<code>drawRect:</code>方法之前，视图对象会自动配置其绘图环境，以便您的代码可以立即开始绘制。 作为此配置的一部分，<code>UIView</code>对象为当前绘图环境创建一个图形上下文（一个<a href="https://developer.apple.com/documentation/coregraphics/cgcontextref" target="_blank" rel="noopener">CGContextRef</a> opaque类型）。 您可以在<code>drawRect:</code>方法中通过调用UIKit的<a href="https://developer.apple.com/documentation/uikit/1623918-uigraphicsgetcurrentcontext" target="_blank" rel="noopener">UIGraphicsGetCurrentContext</a>函数来获取此图形上下文。</p>
<h3 id="在Mac-OS-X中创建窗口图形上下文"><a href="#在Mac-OS-X中创建窗口图形上下文" class="headerlink" title="在Mac OS X中创建窗口图形上下文"></a>在Mac OS X中创建窗口图形上下文</h3><p>略…</p>
<h3 id="创建PDF图形上下文"><a href="#创建PDF图形上下文" class="headerlink" title="创建PDF图形上下文"></a>创建PDF图形上下文</h3><p>略…</p>
<h3 id="创建位图图形上下文"><a href="#创建位图图形上下文" class="headerlink" title="创建位图图形上下文"></a>创建位图图形上下文</h3><p>一个位图图形上下文接受指向内存缓冲区的指针，该缓冲区包含这个位图的存储空间。 当您绘制到位图图形上下文中时，缓冲区将被更新。 释放图形上下文后，您将以指定的像素格式完全更新位图。</p>
<blockquote>
<p><strong>注意：</strong>位图图形上下文有时用于离屏绘制。 当您决定为此来使用位图图形上下文之前，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219-TPXREF101" target="_blank" rel="noopener">Core Graphics Layer Drawing</a>。 CGLayer对象（<code>CGLayerRef</code>）针对离屏绘制进行了优化，因为在任何可能的情况下，Quartz缓存video card上的图层。</p>
</blockquote>
<blockquote>
<p><strong>iOS注意：</strong>iOS应用程序应使用<a href="https://developer.apple.com/documentation/uikit/1623912-uigraphicsbeginimagecontextwitho" target="_blank" rel="noopener">UIGraphicsBeginImageContextWithOptions</a>函数，而不是使用此处描述的低级Quartz函数。 如果您的应用程序使用Quartz创建了屏幕外位图，则位图图形上下文使用的坐标系是默认的Quartz坐标系。 相反，如果您的应用程序通过调用函数<code>UIGraphicsBeginImageContextWithOptions</code>创建图像上下文，则UIKit将与上下文的坐标系统使用相同的转换，这与UIView对象的图形上下文相同。 这允许您的应用程序使用相同的绘图代码，无需担心不同的坐标系。 虽然您的应用程序可以手动调整坐标转换矩阵以获得正确的结果，但在实践中，将会没有性能优势。</p>
</blockquote>
<p>您可以使用函数<code>CGBitmapContextCreate</code>来创建位图图形上下文。 此功能需要以下参数：</p>
<ul>
<li><code>data</code>。 在你希望绘制渲染的内存中提供一个指向目标的指针。该内存块的大小应至少为（<code>bytesPerRow * height</code>）字节。</li>
<li><code>width</code>。 指定位图的宽度（以像素为单位）。</li>
<li><code>height</code>。指定位图的高度（以像素为单位）。</li>
<li><p><code>bitsPerComponent</code>。 指定在内存中用于像素的每个组件的位数。 例如，对于32位像素格式和RGB颜色空间，您可以为每个组件指定一个8位的值。 请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB" target="_blank" rel="noopener">Supported Pixel Formats</a>。</p>
<blockquote>
<p>提示：当您创建位图图形上下文时，如果确保<code>data</code>和<code>bytesPerRow</code>为16字节对齐，则将获得最佳性能。</p>
</blockquote>
</li>
<li><p><code>颜色空间</code>。 用于位图上下文的颜色空间。 您可以在创建位图图形上下文时提供Gray，RGB，CMYK或NULL颜色空间。 有关颜色空间和颜色管理原则的详细信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148" target="_blank" rel="noopener">Color Management Overview</a>。 有关在Quartz中创建和使用颜色空间的信息，请参阅<a href="">Color and Color Spaces</a>。 有关支持的颜色空间的信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-TPXREF101" target="_blank" rel="noopener">Bitmap Images and Image Masks</a>章节中的<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB" target="_blank" rel="noopener">Color Spaces and Bitmap Layout</a>。</p>
</li>
<li><code>bitmapInfo</code>。位图布局信息，表示为<code>CGBitmapInfo</code>常量，用于指定位图是否应包含alpha组件，像素中的alpha组件（如果有的话）的相对位置，是否预先生成alpha组件，以及颜色组件是整数还是浮点值。 有关这些常量是什么，什么时候使用这些常量，以及用于位图图形上下文和图像的Quartz支持的像素格式的这些详细信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-TPXREF101" target="_blank" rel="noopener">Bitmap Images and Image Masks</a>章节中的<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB" target="_blank" rel="noopener">Color Spaces and Bitmap Layout</a>。</li>
</ul>
<p>清单2-5显示了如何创建位图图形上下文。 当您绘制到生成的位图图形上下文时，Quartz将您的绘图作为位图数据记录在指定的内存块中。 清单下面列出每个编号代码行的详细说明。</p>
<p><strong>清单2-5</strong> 创建位图图形上下文<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> MyCreateBitmapContext (<span class="keyword">int</span> pixelsWide,</span><br><span class="line"><span class="keyword">int</span> pixelsHigh)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CGContextRef</span>    context = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> colorSpace;</span><br><span class="line"><span class="keyword">void</span> *          bitmapData;</span><br><span class="line"><span class="keyword">int</span>             bitmapByteCount;</span><br><span class="line"><span class="keyword">int</span>             bitmapBytesPerRow;</span><br><span class="line"></span><br><span class="line">bitmapBytesPerRow   = (pixelsWide * <span class="number">4</span>);<span class="comment">// 1</span></span><br><span class="line">bitmapByteCount     = (bitmapBytesPerRow * pixelsHigh);</span><br><span class="line"></span><br><span class="line">colorSpace = <span class="built_in">CGColorSpaceCreateWithName</span>(kCGColorSpaceGenericRGB);<span class="comment">// 2</span></span><br><span class="line">bitmapData = calloc( bitmapByteCount, <span class="keyword">sizeof</span>(uint8_t) );<span class="comment">// 3</span></span><br><span class="line"><span class="keyword">if</span> (bitmapData == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fprintf (stderr, <span class="string">"Memory not allocated!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">context = <span class="built_in">CGBitmapContextCreate</span> (bitmapData,<span class="comment">// 4</span></span><br><span class="line">pixelsWide,</span><br><span class="line">pixelsHigh,</span><br><span class="line"><span class="number">8</span>,      <span class="comment">// bits per component</span></span><br><span class="line">bitmapBytesPerRow,</span><br><span class="line">colorSpace,</span><br><span class="line">kCGImageAlphaPremultipliedLast);</span><br><span class="line"><span class="keyword">if</span> (context== <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">free (bitmapData);<span class="comment">// 5</span></span><br><span class="line">fprintf (stderr, <span class="string">"Context not created!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CGColorSpaceRelease</span>( colorSpace );<span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> context;<span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是代码所做的事：</p>
<ol>
<li>声明一个变量来表示每行的字节数。 该示例中位图中的每个像素由4个字节表示; 每个红色，绿色，蓝色和阿尔法都有8位。</li>
<li>创建一个通用的RGB颜色空间。 您也可以创建一个CMYK颜色空间。 有关更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101" target="_blank" rel="noopener">Color and Color Spaces</a>，以及有关通用色彩空间与依赖于设备的颜色空间的讨论。</li>
<li>调用<code>calloc</code>函数来创建和清除存储位图数据的内存块。 此示例创建一个32位RGBA位图（即，每像素32位的数组，每个像素包含红，绿，蓝和阿尔法信息的8位）。 位图中的每个像素占用4个字节的内存。 在Mac OS X 10.6和iOS 4中，可以省略此步骤 - 如果将NULL作为位图数据传递，Quartz会自动为位图分配空间。</li>
<li>创建位图图形上下文，提供位图数据，位图的宽度和高度，每个组件的位数，每行的字节数，颜色空间以及指定位图是否应包含Alpha通道的常数和像素中的相对位置。常数<code>kCGImageAlphaPremultipliedLast</code>表示α分量存储在每个像素的最后一个字节中，并且颜色分量已经乘以此Alpha值。 有关预乘α的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF119" target="_blank" rel="noopener">The Alpha Value</a>。</li>
<li>如果由于某种原因未创建上下文，则释放分配给位图数据的内存。</li>
<li>释放颜色空间。</li>
<li>返回位图图形上下文。当不再需要时，调用者必须释放图形上下文。</li>
</ol>
<p>清单2-6显示了调用MyCreateBitmapContext创建位图图形上下文的代码，使用位图图形上下文来创建CGImage对象，然后将生成的图像绘制到窗口图形上下文。 图2-3显示了绘制到窗口的图像。 清单下面列出每个编号代码行的详细说明。<br><strong>清单2-6</strong> 绘制到位图图形上下文<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> myBoundingBox;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">myBoundingBox = <span class="built_in">CGRectMake</span> (<span class="number">0</span>, <span class="number">0</span>, myWidth, myHeight);<span class="comment">// 2</span></span><br><span class="line">myBitmapContext = MyCreateBitmapContext (<span class="number">400</span>, <span class="number">300</span>);<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// ********** Your drawing code here ********** // 4</span></span><br><span class="line"><span class="built_in">CGContextSetRGBFillColor</span> (myBitmapContext, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">CGContextFillRect</span> (myBitmapContext, <span class="built_in">CGRectMake</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span> ));</span><br><span class="line"><span class="built_in">CGContextSetRGBFillColor</span> (myBitmapContext, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">.5</span>);</span><br><span class="line"><span class="built_in">CGContextFillRect</span> (myBitmapContext, <span class="built_in">CGRectMake</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span> ));</span><br><span class="line">myImage = <span class="built_in">CGBitmapContextCreateImage</span> (myBitmapContext);<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(myContext, myBoundingBox, myImage);<span class="comment">// 6</span></span><br><span class="line"><span class="keyword">char</span> *bitmapData = <span class="built_in">CGBitmapContextGetData</span>(myBitmapContext); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">CGContextRelease</span> (myBitmapContext);<span class="comment">// 8</span></span><br><span class="line"><span class="keyword">if</span> (bitmapData) free(bitmapData); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">CGImageRelease</span>(myImage);</span><br></pre></td></tr></table></figure></p>
<p>下面是这些代码所做的事：</p>
<ol>
<li>声明一个变量来存储边界框的起点和尺寸，Quartz将绘制从位图图形上下文创建的图像。</li>
<li>将边框的原点设置为（0,0），并将宽度和高度设置为先前声明的变量，但其声明未显示在此代码中。</li>
<li>调用应用程序提供的函数<code>MyCreateBitmapContext</code>（参见清单2-5）来创建一个400像素宽和300像素高的位图上下文。 您可以使用适合您的应用程序的任何维度创建位图图形上下文。</li>
<li>调用Quartz 2D函数来绘制位图图形上下文。 您将使用适合您的应用程序的绘图代码替换此代码和接下来的四行代码。</li>
<li>从位图图形上下文创建Quartz 2D图像（<code>CGImageRef</code>）。</li>
<li>将图像绘制到由边界框指定的窗口图形上下文中的位置。 边界框指定用于绘制图像的用户空间中的位置和尺寸。<br>此示例不显示窗口图形上下文的创建。 有关如何创建一个的信息，请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBDCHAC" target="_blank" rel="noopener">Creating a Window Graphics Context in Mac OS X</a>。</li>
<li>获取与位图图形上下文相关联的位图数据。</li>
<li>当不再需要时，释放位图图形上下文。</li>
<li>释放位图数据（如果存在）。</li>
<li>当不再需要时释放图像。</li>
</ol>
<p><strong>图2-3</strong> 从位图图形上下文创建并绘制到窗口图形上下文的图像<br><img src="/source/cg3_p_1.gif" alt=""></p>
<h3 id="支持的像素格式"><a href="#支持的像素格式" class="headerlink" title="支持的像素格式"></a>支持的像素格式</h3><p>表2-1总结了支持位图图形上下文，相关联的颜色空间（<code>cs</code>）以及格式首次可用的Mac OS X版本 的像素格式。 像素格式被指定为bit per pixel（bpp）和bit per component（bpc）。 该表还包括与该像素格式相关联的位图信息常数。 有关每个位图信息格式常量表示的详细信息，请参阅<a href="https://developer.apple.com/documentation/coregraphics/cgimage" target="_blank" rel="noopener">CGImage Reference</a>。</p>
<p><strong>表2-1</strong> 位图图形上下文支持的像素格式<br>| 颜色空间 | 像素格式和位图信息常量 | 可用性 |<br>|:——|:——|:— |<br>| Null | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |<br>| Gray | 8 bpp, 8 bpc, kCGImageAlphaNone | Mac OS X, iOS |<br>| Gray | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |<br>| Gray | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |<br>| Gray | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |<br>| RGB | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |<br>| RGB | 8 bpp, 8 bpc, kCGImageAlphaOnly | Mac OS X, iOS |</p>
<h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>位图图形上下文支持抗锯齿功能，这是人工修正当您绘制文字或形状时您有时在位图图像中看到的锯齿状（或别名）边缘的过程。 当位图的分辨率显著低于您的眼睛的分辨率时，会发生这些锯齿状边缘。 为了使对象在位图中显得平滑，Quartz对于围绕形状轮廓的像素使用不同的颜色。 通过以这种方式混合颜色，形状看起来平滑。 您可以在图2-4中看到使用抗锯齿的效果。 您可以通过调用函数<code>CGContextSetShouldAntialias</code>来关闭特定位图图形上下文的反锯齿。 抗锯齿设置是图形状态的一部分。</p>
<p>您可以通过使用函数<code>CGContextSetAllowsAntialiasing</code>来控制是否允许特定图形上下文的反锯齿。 给函数传<code>true</code>可以允许反锯齿; <code>false</code>不允许反锯齿。 此设置不是图形状态的一部分。 当上下文和图形状态设置设置为<code>true</code>时，Quartz会执行抗锯齿。</p>
<p><strong>图2-4</strong> 混叠和反锯齿图的比较<br><img src="/source/cg3_p_2.jpg" alt=""></p>
<h3 id="获取打印图形上下文"><a href="#获取打印图形上下文" class="headerlink" title="获取打印图形上下文"></a>获取打印图形上下文</h3><p>Mac OS X中的Cocoa应用程序通过定制<a href="https://developer.apple.com/documentation/appkit/nsview" target="_blank" rel="noopener">NSView</a>子类实现打印。 通过调用其<a href="https://developer.apple.com/documentation/appkit/nsview/1483705-printview" target="_blank" rel="noopener">print:</a>方法，可以看到打印的视图。 然后，该视图将创建一个针对打印机的图形上下文，并调用其<a href="https://developer.apple.com/documentation/appkit/nsview/1483686-drawrect" target="_blank" rel="noopener">drawRect:</a>方法。 您的应用程序使用相同的绘图代码绘制到用于绘制到屏幕的打印机。 它还可以自定义<code>drawRect:</code>将图像调用到与发送到屏幕的打印机不同的打印机。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/四、Core-Graphics-Paths/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/四、Core-Graphics-Paths/" itemprop="url">四、Core Graphics - Paths</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T00:00:00+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Core Graphics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>路径定义一个或多个形状或子路径。 子路径可以由直线，曲线或两者的组合。 它可以被打开或关闭。 子路径可以是简单的形状，例如线，圆，矩形或星形，或更复杂的形状，例如山脉或抽象涂鸦的轮廓。 图3-1显示了可以创建的一些路径。 直线（在图的左上方）可以是虚线; 线条也可以是实线。 波浪路径（中间顶部）由几条曲线组成，是一条开放的路径。 同心圆被填充，但没有边框色。 加利福尼亚州图形是一条封闭的路径，由许多曲线和线条组成，路径既有边框色又被填充。 星星说明了填充路径的两个选项，您将在本章后面阅读。</p>
<p><em>图3-1 Quartz支持基于路径的绘图</em><br><img src="/source/cg4_p_1.gif" alt=""></p>
<p>在本章中，您将了解组成路径的构建块，如何描绘和绘制路径以及影响路径外观的参数。</p>
<h3 id="路径创建和路径绘画"><a href="#路径创建和路径绘画" class="headerlink" title="路径创建和路径绘画"></a>路径创建和路径绘画</h3><p>路径创建和路径绘制是两个分开的任务。 首先你创建一个路径。 当您要呈现(渲染)路径时，您要求Quartz来绘制它。 如图3-1所示，您可以选择给路径上边框色，填充路径，或者两个都要。 您还可以使用一条路径来约束在创建的路径范围内的其他对象的绘制，这实际上是一个剪切区域。</p>
<p>图3-2显示了已绘制的路径，其中包含两个子路径。左边的子路径是一个矩形，右边的子路径是由直线和曲线组成的抽象形状。每个子路径都被填满了，它的轮廓也被描边了。</p>
<p><em>Figure 3-2  A path that contains two shapes, or subpaths</em><br><img src="/source/cg4_p_2.gif" alt=""></p>
<p>图3-3显示了单独绘制的多条路径。每条路径都包含一个随机生成的曲线，其中一些是填充的，另一些则是描边的。绘图用剪切区域限制到圆形区域。<br><em>Figure 3-3  A clipping area constrains drawing</em><br><img src="/source/cg4_p_3.gif" alt=""></p>
<h3 id="The-Building-Blocks"><a href="#The-Building-Blocks" class="headerlink" title="The Building Blocks"></a>The Building Blocks</h3><p>子路径由线、弧和曲线组成。Quartz还提供了通过使用单个方法来添加矩形和椭圆的便捷方法。点也是路径的基本构建块，因为点定义了形状的开始和结束位置。</p>
<h4 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h4><p>点是在用户空间中指定位置的x和y坐标。您可以调用函数<code>CGContextMoveToPoint</code>来指定新的子路径的起始位置。Quartz一直保持着对用于路径构造的最后一个位置的点(current point)的跟踪。例如，如果调用函数<code>CGContextMoveToPoint</code>来设置(10,10)的位置，则将当前点移动到(10,10)。如果你画一条长度为50的水平线，那么直线上的最后一点就是(60,10)，这个点将成为成为当前点。直线、弧线和曲线总是从当前点出发。</p>
<p>在大多数情况下，您指定一个点，通过向Quartz函数传递两个浮点值来指定x和y坐标。一些函数要求您传递一个CGPoint数据结构，该结构包含两个浮点值。</p>
<h4 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h4><p>线由它的终点定义。它的起始点总是假定为当前点(current point)，因此当您创建一个人Line时，您只需指定它的终点。您可以使用函数<code>CGContextAddLineToPoint</code>向子路径拼接一条Line。</p>
<p>您可以通过调用函数<code>CGContextAddLines</code>向路径添加一系列连接的Lines。你向这个函数传入一个包含点的数组。第一个点必须是第一行的起点；其余的点是终点。Quartz在第一个点开始一个新的子路径，并将一条直线段连接到每个终点。</p>
<h4 id="Arcs"><a href="#Arcs" class="headerlink" title="Arcs"></a>Arcs</h4><p>Arcs就是圆弧线，Quartz提供了两个创建arcs的函数。函数<code>CGContextAddArc</code>从一个圆创建一个曲线段。你指定圆心、半径和弧度。您可以通过指定2π的弧度来创建一个完整的圆。图3-4显示了单独绘制的多条路径。每个路径包含一个随机生成的圆；有的被填满，有的被描边。</p>
<p><em>Figure 3-4  Multiple paths; each path contains a randomly generated circle</em><br><img src="/source/cg4_p_4.gif" alt=""><br>函数<code>CGContextAddArcToPoint</code>在您想要绕过一个矩形的角时非常理想。Quartz使用您提供的端点创建两条切线。圆弧的每个端点都是一条切线的切线点，如图3-5所示。这个圆的红色部分是画出来的。</p>
<p><em>Figure 3-5  Defining an arc with two tangent lines and a radius</em><br><img src="/source/cg4_p_5.gif" alt=""><br>如果当前路径已经包含一条子路径，则Quartz将从当前点到弧段的起始点附加一条直线段。如果当前路径是空的，Quartz在起始点创建一个新的子路径，并且不会添加初始的直线段。</p>
<h4 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h4><p>图3-6展示了通过单独绘制多条路径创建的各种曲线。每个路径包含一个随机生成的曲线;有的被填满，有的被描边。<br><em>Figure 3-6  Multiple paths; each path contains a randomly generated curve</em><br><img src="/source/cg4_p_6.gif" alt=""></p>
<p>使用函数<code>CGContextAddCurveToPoint</code>从当前点添加一个立方体Bezier曲线，使用控制点和指定的终点。图3-7显示了由图中显示的当前点、控制点和终点所产生的立方体Bezier曲线。两个控制点的位置决定了曲线的几何形状。如果控制点都在起止点以上，则曲线向上拱起。如果控制点都在起始点和结束点以下，则曲线向下弯曲。</p>
<p><em>Figure 3-7  A cubic Bézier curve uses two control points</em><br><img src="/source/cg4_p_7.gif" alt=""></p>
<p>你可以通过调用函数<code>CGContextAddQuadCurveToPoint</code>从当前点添加一个二次贝塞尔曲线，并指定一个控制点和一个终点。图3-8显示了使用相同端点但不同控制点的两个曲线。控制点决定曲线拱的方向。不可能用一个二次曲线来创造出很多有趣的形状，因为二次曲线只使用一个控制点。例如，不可能使用单个控制点来创建交叉。</p>
<p><em>Figure 3-8  A quadratic Bézier curve uses one control point</em><br><img src="/source/cg4_p_8.gif" alt=""></p>
<h4 id="Closing-a-Subpath"><a href="#Closing-a-Subpath" class="headerlink" title="Closing a Subpath"></a>Closing a Subpath</h4><p>要关闭当前的子路径，您的应用程序应该调用<code>CGContextClosePath</code>。该函数从当前点添加一条线段到子路径的起始点，并关闭子路径。在子路径的起始点结束的行、弧和曲线实际上并没有关闭子路径。您必须显式地调用<code>CGContextClosePath</code>来关闭子路径。一些Quartz函数处理路径的子路径，就像它们被应用程序关闭一样。这些命令处理每个子路径，就像您的应用程序调用CGContextClosePath来关闭它，隐式地将一条线段添加到子路径的起始点。关闭子路径之后，如果您的应用程序发出额外的调用，以添加行、弧线或曲线到路径，Quartz在您刚刚关闭的子路径的起点开始一条新的子路径。</p>
<h4 id="Ellipses（椭圆）"><a href="#Ellipses（椭圆）" class="headerlink" title="Ellipses（椭圆）"></a>Ellipses（椭圆）</h4><p>椭圆本质上是一个压扁的圆。你通过定义两个焦点来创建一个点，然后画出所有的点，这些点在一个距离上，从椭圆的任意一点到一个焦点到另一个焦点的距离都是相同的值。图3-9显示了单独绘制的多条路径。每个路径包含一个随机生成的椭圆;有的被填满，有的被描边。</p>
<p><em>Figure 3-9  Multiple paths; each path contains a randomly generated ellipse</em><br><img src="/source/cg4_p_9.gif" alt=""></p>
<p>您可以通过调用<code>CGContextAddEllipseInRect</code>函数在当前路径添加一个椭圆。您需要提供一个定义椭圆边界的矩形。Quartz使用一系列贝塞尔曲线来描绘椭圆。椭圆的中心是矩形的中心。如果矩形的宽度和高度是相等(即正方形)，那么椭圆就是圆形的，半径等于矩形宽度(或高度)的一半。如果矩形的宽度和高度不相等，则定义椭圆的主要和小轴。</p>
<p>添加到路径上的椭圆以一个移动操作开始，以一个近子路径操作结束，所有的动作都以顺时针方向移动。</p>
<h4 id="Rectangles"><a href="#Rectangles" class="headerlink" title="Rectangles"></a>Rectangles</h4><p>您可以通过调用函数<code>CGContextAddRect</code>向当前路径添加一个矩形。您提供的CGRect结构包含矩形的原点及其宽度和高度。</p>
<p>添加到路径上的矩形以一个移动操作开始，以一个关闭子路径操作结束，所有的动作都以逆时针方向移动。</p>
<p>通过调用函数<code>CGContextAddRects</code>并提供CGRect结构的数组，可以向当前路径添加许多矩形。图3-10显示了单独绘制的多条路径。每个路径包含一个随机生成的矩形；有的被填满，有的被描边。</p>
<p><em>Figure 3-10  Multiple paths; each path contains a randomly generated rectangle</em><br><img src="/source/cg4_p_10.gif" alt=""></p>
<h3 id="Creating-a-Path"><a href="#Creating-a-Path" class="headerlink" title="Creating a Path"></a>Creating a Path</h3><p>当您希望在图形上下文中构造路径时，您通过调用函数<code>CGContextBeginPath</code>来对Quartz进行信号处理。接下来，通过调用函数<code>CGContextMoveToPoint</code>，为第一个形状(或子路径)设置起点。在你建立第一个点之后，你可以在路径上添加线条、弧线和曲线，记住以下几点：</p>
<ul>
<li>在开始新路径之前，请调用函数<code>CGContextBeginPath</code>。</li>
<li>直线、弧线和曲线从当前点开始绘制。空路径没有当前点；您必须调用<code>CGContextMoveToPoint</code>来设置第一个子路径的起始点，或者调用一个隐式为您做这个的方便函数。</li>
<li>当您想要关闭路径中的当前子路径时，调用函数CGContextClosePath将一个段连接到子路径的起点。随后的路径调用开始一个新的子路径，即使您没有显式地设置一个新的起始点。</li>
<li>当你绘制弧线时，Quartz在当前点和弧线起始点之间画一条线。</li>
<li>添加椭圆和矩形的石英例程为路径添加一个新的闭子路径。</li>
<li>您必须调用一个绘图函数来填充或描出路径，因为创建路径不会绘制路径。请参阅<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-CJBEIHHJ" target="_blank" rel="noopener">Painting a Path</a>来获取详细信息。</li>
</ul>
<p>绘制路径之后，它将从图形环境中刷新。您可能不希望如此容易地丢失您的路径，特别是如果它描述了您希望一次又一次使用的复杂场景。出于这个原因，Quartz为创建可重用的paths-<code>CGPathRef</code>和<code>CGMutablePathRef</code>提供了两种数据类型。您可以调用函数<code>CGPathCreateMutable</code>来创建一个可变的CGPath对象，您可以添加线、弧线、曲线和矩形。Quartz提供了一组与构建块中讨论的函数并行的CGPath函数。路径函数在CGPath对象上运行，而不是在图形上下文中。这些函数是：</p>
<ul>
<li>用<code>CGPathCreateMutable</code>替换<code>CGContextBeginPath</code>。</li>
<li>用<code>CGPathMoveToPoint</code>替换<code>CGContextMoveToPoint</code>。</li>
<li>用<code>CGPathAddLineToPoint</code>替换<code>CGContextAddLineToPoint</code>。</li>
<li>用<code>CGPathAddCurveToPoint</code>替换<code>CGContextAddCurveToPoint</code>。</li>
<li>用<code>CGPathAddEllipseInRect</code>替换<code>CGContextAddEllipseInRect</code>。</li>
<li>用<code>CGPathAddArc</code>替换<code>CGContextAddArc</code>。</li>
<li>用<code>CGPathAddRect</code>替换<code>CGContextAddRect</code>。</li>
<li>用<code>CGPathCloseSubpath</code>替换<code>CGContextClosePath</code>。</li>
</ul>
<p>有关路径函数的完整列表，请参阅Quartz 2D参考集合。</p>
<p>当您想要添加到图形上下文的路径时，您调用函数<code>CGContextAddPath</code>。路径在图形环境中保持，直到Quartz绘制它为止。您可以通过调用<code>CGContextAddPath</code>来再次添加路径。</p>
<blockquote>
<p>注意：您可以通过调用<code>CGContextReplacePathWithStrokedPath</code>方法来替代路径的图形上下文的描边版本的路径。</p>
</blockquote>
<h3 id="Painting-a-Path"><a href="#Painting-a-Path" class="headerlink" title="Painting a Path"></a>Painting a Path</h3><p>你可以用描边或填充来绘制当前路径。Stroking画了一条横跨这条小路的线。填充物画出路径中包含的区域。Quartz有一些函数，可以让您描边路径、填充路径或同时描边或者填充路径。描边线的特征(宽度、颜色等)、填充色和Quartz用来计算填充区域的方法都是图形状态的一部分(见图表状态)。</p>
<h4 id="Parameters-That-Affect-Stroking-（影响描边的参数）"><a href="#Parameters-That-Affect-Stroking-（影响描边的参数）" class="headerlink" title="Parameters That Affect Stroking （影响描边的参数）"></a>Parameters That Affect Stroking （影响描边的参数）</h4><p>您可以通过修改表3-1中列出的参数来影响路径。这些参数是图形状态的一部分，这意味着您为参数设置的值会影响所有后续的遍历，直到您将参数设置为另一个值。</p>
<p><em>Table 3-1  Parameters that affect how Quartz strokes the current path</em><br>| Parameter | Function to set parameter value |<br>| :————| :———————————|<br>|Line Width|CGContextSetLineWidth|<br>|Line join |CGContextSetLineJoin|<br>|Line cap |CGContextSetLineCap|<br>|Miter limit|CGContextSetMiterLimit|<br>|Line dash pattern|CGContextSetStrokeColorSpace|<br>|Stroke color space|CGContextSetStrokeColorSpace|<br>|Stroke color|CGContextSetStrokeColor CGContextSetStrokeColorWithColor|<br>|Stroke pattern|CGContextSetStrokePattern|</p>
<p><em>line width</em>是线的总宽度，表示为用户空间的单位。这条线横跨这条路，两边各有一半宽度。</p>
<p><em>line join (线路连接)</em>指定了Quartz如何绘制连接线段之间的连接点。Quartz支持表3-2中描述的线条连接样式。默认样式是 <em>miter join</em>。</p>
<p><em>Table 3-2 Line join style</em><br>| Style | Appearance | Description |<br>| :—: | :—: | :—: |<br>| Miter join | <img src="/source/cg4_p_11.gif" alt=""> | Quartz将两段笔画的外边缘延伸到一个角度，就像在画框中一样。如果线段以太尖的角度相交，则使用斜角连接。如果一个线段的长度除以线段的宽度大于斜线的限制，那么它的线段就太锋利了。 |<br>| Round join | <img src="/source/cg4_p_12.gif" alt=""> | Quartz画出一个半圆的圆弧，直径等于端点上的线宽。封闭的区域填满了。 |<br>| Bevel join | <img src="/source/cg4_p_13.gif" alt=""> | Quartz完成了两个部分的对接帽。在线段的两端所产生的缺口被一个三角形填满。 |</p>
<p><em>line cap</em>指定了<code>CGContextStrokePath</code>用于绘制该行端点的方法。Quartz支持表3-3所述的线帽样式。默认样式是<em>butt cap</em>。</p>
<p><em>Table 3-3 Line cap styles</em><br>| Style | Appearance | Description |<br>| :—: | :—: | :—:|<br>| Butt cap |||<br>| Round cap |||<br>| Projecting square cap |||</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/11/二、Core-Graphics-Overview-of-Quartz-2D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/二、Core-Graphics-Overview-of-Quartz-2D/" itemprop="url">二、Core Graphics - Overview of Quartz 2D</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T00:00:00+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Core Graphics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考文章：<br>百度搜索：”ios shading object”</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/7be4c366c048" target="_blank" rel="noopener">https://www.jianshu.com/p/7be4c366c048</a><br><a href="http://blog.csdn.net/hello_hwc?viewmode=list" target="_blank" rel="noopener">http://blog.csdn.net/hello_hwc?viewmode=list</a><br><a href="http://blog.csdn.net/hello_hwc/article/details/49283275" target="_blank" rel="noopener">http://blog.csdn.net/hello_hwc/article/details/49283275</a></p>
</blockquote>
<ol>
<li>2D 即two-dimensional drawing engine ：二维绘图引擎.</li>
<li>可用于基于路径的绘图、透明、着色、绘制阴影、透明层、颜色管理、反锯齿渲染、PDF文档生成和PDF元数据访问。只要可能，Quartz 2D就会利用图形硬件的力量。</li>
<li><p>图形上下文是一种不透明的数据类型(<code>CGContextRef</code>)，它封装了用于将图像绘制到输出设备上的信息，如PDF文件、位图或显示窗口的窗口。如下图：<br><img src="/source/cg2_p_1.gif" alt=""></p>
</li>
<li><p>bitmap图形的上下文允许你将RGB颜色，CMYK颜色，或灰度图转换成位图。位图是像素的矩形数组(或光栅)，每个像素代表图像中的一个点。位图图像也称为采样图像。请参见创建位图图形上下文。</p>
<blockquote>
<p>位图：像素点的矩形数组。即一个<strong>二维数组</strong>，里面的元素是像素点。</p>
</blockquote>
</li>
<li><p>PDF图形的上下文允许您创建一个PDF文件。在PDF文件中，您的绘图是作为命令序列保存的。PDF文件和位图之间有一些显著的区别:</p>
<blockquote>
<ul>
<li>与位图不同的是，PDF文件可能包含不止一个页面。</li>
<li>当您从一个不同设备上的PDF文件中提取一个页面时，生成的图像将针对该设备的显示特性进行优化。</li>
<li>PDF文件是独立于自然的分辨率，其大小可以在不牺牲图像细节的情况下增加或减少。位图图像的用户感知的质量与图所要查看的分辨率的分辨率有关。</li>
</ul>
</blockquote>
</li>
<li><p>一个层上下文(CGLayerRef)是一个与另一个图形上下文关联的离屏绘制目的地。它被设计是因为当把layer绘制到创建它的图形上下文时，它能表现出最优的性能。对于离屏绘制来说，相对于位图图形上下文，图层上下文可以是一个更好的选择。</p>
</li>
</ol>
<h3 id="三、Quartz-2D-Opaque-Data-Types"><a href="#三、Quartz-2D-Opaque-Data-Types" class="headerlink" title="三、Quartz 2D Opaque Data Types"></a>三、Quartz 2D Opaque Data Types</h3><p>Quartz 2D通过应用程序操作的不透明数据类型创建对象，以实现特定的绘图输出。图1-3显示了当您将绘图操作应用到Quartz 2D所提供的三个对象时所能获得的结果。例如:</p>
<ul>
<li>您可以通过创建一个<code>PDF page</code>对象来旋转和显示一个PDF页面，将旋转操作应用到图形上下文，并要求Quartz 2D将页面绘制到图形上下文。</li>
<li>您可以通过创建一个<code>pattern</code>(CGPattern用于重复绘制)对象来绘制一个图案，定义组成图案的形状，并设置Quartz 2D以在绘制图形上下文时使用该图案作为绘图颜料。</li>
<li>您可以通过创建一个<code>shading</code>(CGShading用于绘制梯度)对象来填充一个轴向或径向阴影的区域，提供一个函数来确定阴影中每个点的颜色，然后要求Quartz 2D使用该阴影作为填充色</li>
</ul>
<p><em>Figure 1-3</em><br><img src="/source/cg2_p_2.gif" alt=""></p>
<p>Quartz 2D中的opaque data types:</p>
<ul>
<li>CGPathRef</li>
<li>CGImageRef：基于你提供的样本数据，来表示位图图像和位图图像遮罩。</li>
<li>CGLayerRef</li>
<li>CGPatternRef</li>
<li>CGShadingRef</li>
<li>CGFunctionRef</li>
<li>CGColorRef</li>
<li>CGImageSourceRef</li>
<li>CGFontRef：用于绘制文本。</li>
<li>CGPDFDictionaryRef</li>
<li>CGPDFScannerRef</li>
<li>CGPSConverterRef</li>
</ul>
<h3 id="四、Graphics-States"><a href="#四、Graphics-States" class="headerlink" title="四、Graphics States"></a>四、Graphics States</h3><p>当前图形状态的参数可以影响绘制操作的结果。图形状态包含了一些参数，否则这些参数将被用作绘制例程的参数。绘制到图形上下文的例程查询图形状态以确定如何呈现结果。例如，当您调用一个函数来设置填充颜色时，那么您正在修改存储在当前图形状态中的值。当前图形状态的其他常用元素包括行宽、当前位置和文本字体大小。</p>
<p>图形上下文包含一堆图形状态。当Quartz创建一个图形上下文时，堆栈是空的。保存图形状态时，Quartz将当前图形状态的副本推送到堆栈上。当您恢复图形状态时，Quartz会弹出堆栈顶部的图形状态。弹出的状态变成当前的图形状态。</p>
<p>为了保存当前的图形状态，使用函数CGContextSaveGState将当前图形状态的拷贝推到堆栈上。若要还原以前保存的图形状态，请使用函数CGContextRestoreGState来把置于堆栈顶部的图形状态替换为当前的图形状态。</p>
<p>注意，并不是当前绘图环境的所有方面都是图形状态的元素。例如，当前路径不被认为是图形状态的一部分，因此当您调用函数CGContextSaveGState时，它不会被保存。表1-1列出了调用此函数时保存的图形状态参数。</p>
<p>Table 1-1  Parameters that are associated with the graphics state</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameters</th>
<th style="text-align:left">Discussed In this chapter</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Current transformation matrix (CTM)</td>
<td style="text-align:left">Transforms</td>
</tr>
<tr>
<td style="text-align:left">Clipping area</td>
<td style="text-align:left">Paths</td>
</tr>
<tr>
<td style="text-align:left">Line: width, join, cap, dash, miter limit</td>
<td style="text-align:left">Paths</td>
</tr>
<tr>
<td style="text-align:left">Accuracy of curve estimation (flatness)</td>
<td style="text-align:left">Paths</td>
</tr>
<tr>
<td style="text-align:left">Anti-aliasing setting</td>
<td style="text-align:left">Graphics Contexts</td>
</tr>
<tr>
<td style="text-align:left">Color: fill and stroke settings</td>
<td style="text-align:left">Color and Color Spaces</td>
</tr>
<tr>
<td style="text-align:left">Alpha value (transparency)</td>
<td style="text-align:left">Color and Color Spaces</td>
</tr>
<tr>
<td style="text-align:left">Rendering intent</td>
<td style="text-align:left">Color and Color Spaces</td>
</tr>
<tr>
<td style="text-align:left">Color space: fill and stroke settings</td>
<td style="text-align:left">Color and Color Spaces</td>
</tr>
<tr>
<td style="text-align:left">Text: font, font size, character spacing, text drawing mode</td>
<td style="text-align:left">Text</td>
</tr>
<tr>
<td style="text-align:left">Blend mode</td>
<td style="text-align:left">Paths and Bitmap Images and Image Masks</td>
</tr>
</tbody>
</table>
<h3 id="五、Quartz-2D-Coordinate-Systems"><a href="#五、Quartz-2D-Coordinate-Systems" class="headerlink" title="五、Quartz 2D Coordinate Systems"></a>五、Quartz 2D Coordinate Systems</h3><p>图1-4所示的坐标系统定义了用于表示在页面上绘制对象的位置和大小的位置的范围。您可以在用户空间坐标系统中指定图形的位置和大小，或者更简单地说，用户空间。坐标被定义为浮点值。</p>
<p><em>Figure 1-4  The Quartz coordinate system</em><br><img src="/source/cg2_p_3.gif" alt=""></p>
<p>由于不同的设备具有不同的底层成像能力，所以图形的位置和大小必须以设备独立的方式来定义。例如，屏幕显示设备可能能够显示每英寸不超过96个像素，而打印机可能能够显示300像素每英寸。如果在设备级别上定义了坐标系统(在本例中，是96个像素或300像素)，那么在该空间中绘制的对象不可能在复制到其他设备上后不出现明显的失真。它们会显得太大或太小。</p>
<p>Quartz通过一个单独的坐标系统-用户空间，使用当前转换矩阵(或CTM)，把它映射到输出设备的坐标系统-设备空间，来实现设备的独立。矩阵是用来有效描述一组相关方程的数学构造。当前的转换矩阵是一种称为仿射变换的特殊类型的矩阵，它通过应用平移、旋转和缩放操作(计算移动、旋转和调整坐标系统)将点从一个坐标空间映射到另一个坐标空间。</p>
<p>当前的转换矩阵有一个次要的用途:它允许您转换对象的绘制方式。例如，要画一个旋转45度的盒子，你在画这个盒子之前旋转这个页面的坐标系统(CTM)。Quartz通过旋转后的坐标系统来绘制到输出设备。</p>
<p>用户空间中的一个点由坐标对(x,y)表示，其中x表示沿水平轴(左和右)的位置，y表示垂直轴(上下)。用户坐标空间的原点是点(0,0)。原点位于页面的左下角，如图1-4所示。在Quartz的默认坐标系统中，x轴从左向右移动。当y轴从底部移动到页面顶端时，它的值会增加。</p>
<p>一些技术使用不同的默认坐标系统来设置它们的图形上下文，而不是Quartz所使用的。相对于Quartz，这样的坐标系统是一个改进的坐标系，在执行一些石英绘图操作时必须得到补偿。最常见的修改坐标系统将原点放在上下文的左上角，并更改y轴指向页面的底部。在一些地方，您可能会看到这个特定的坐标系使用如下:</p>
<ul>
<li>In Mac OS X, a subclass of NSView that overrides its isFlipped method to return YES.</li>
<li>In iOS, a drawing context returned by an UIView.</li>
<li>In iOS, a drawing context created by calling the UIGraphicsBeginImageContextWithOptions function.</li>
</ul>
<p>UIKit使用修改后的坐标系返回Quartz绘图上下文的原因是UIKit使用了一个不同的默认坐标约定；它将转换应用于它所创建的Quartz上下文，从而使它们与它的约定相匹配。如果您的应用程序要使用相同的绘图程序画一个UIView对象和一个PDF图形上下文(由Quartz创建并使用默认坐标系)，您需要应用一个变换，这样PDF格式的图形上下文可以接受相同的修改后的坐标系统。为此，应用转换将原点转换为PDF上下文的左上角，并按-1缩放y坐标。</p>
<p>使用缩放变换来翻转y坐标，改变了一些在Quartz绘图中的约定。例如，如果您调用CGContextDrawImage来将图像绘制到上下文中，那么当它被绘制到目标中时，图像会被转换。类似地，路径绘制例程接受参数，该参数指定在默认坐标系统中是否以顺时针或逆时针方向绘制弧线。如果一个坐标系统被修改，结果也会被修改，就像在镜子里反射的图像一样。在图1-5中，当向Quartz中传递相同的参数时，在默认坐标系统中的结果是顺时针方向的，但是当y坐标因为变换被翻转后，结果是逆时针方向。</p>
<p><em>Figure 1-5  Modifying the coordinate system creates a mirrored image.</em><br><img src="/source/cg2_p_4.gif" alt=""></p>
<p>这取决于您的应用程序调整任何Quartz，使它具有一个应用于它的转换的上下文。例如，如果您希望图像或PDF能够正确地绘制到图形上下文中，您的应用程序可能需要临时调整图形上下文的CTM。在iOS中，如果你使用UIImage对象来包装你创建的CGImage对象，你不需要修改CTM。UIImage对象自动补偿UIKit应用的修改后的坐标系。</p>
<blockquote>
<p><strong>Important</strong>：上面的讨论对于理解如果您打算编写在iOS中直接针对Quartz的应用程序是非常必要的，但是这还不够。在ios3.2和之后，当UIKit为您的应用程序创建一个绘图上下文时，它还会对上下文进行额外的更改，以匹配默认的UIKit约定。具体来说，不受CTM影响的<code>Patterns</code>和<code>Shadows</code>会被单独调整，使它们的约定与UIKit的坐标系统相匹配。在这种情况下，您的应用程序可以用来更改由Quartz创建的上下文来匹配由UIKit提供的上下文的行为，因此没有与CTM相同的机制。您的应用程序必须认识到它所使用的上下文，并根据上下文的期望调整其行为。</p>
</blockquote>
<h3 id="六、Memory-Management-Object-Ownership"><a href="#六、Memory-Management-Object-Ownership" class="headerlink" title="六、Memory Management: Object Ownership"></a>六、Memory Management: Object Ownership</h3><p>Quartz使用了Core Foundation内存管理模型，在该模型中，对象是引用计数的。当Core Foundation对象被创建时，对象是以引用计数为1开始的。你可以通过调用一个方法来retain这个对象，以此来增加它的引用计数，也可以通过调用一个方法来release这个对象，从而减少它的引用计数。当引用计数被减为0时，这个对象就被释放了。这种模式使得对象可以安全的被其他对象所引用。</p>
<p>有一些简单的规则需要记下：</p>
<ul>
<li>如果你创建或者复制一个对象，你就拥有它，所以你必须释放它。也就是说，在通常情况下，如果你通过一个方法名包含”Create”或者”Copy”的函数获得一个对象，你必须在使用完这个对象之后释放它。否则，将导致内存泄漏。</li>
<li>如果你通过一个方法名不包含”Create”或者”Copy”的函数获得一个对象，那么你并没有持有这个对象，所以你不能释放它。这个对象将在未来的某个时间由它的拥有者释放。</li>
<li>如果你没有拥有一个对象，但是你需要持有它，那么你必须在这样做的时候<code>retain</code>和<code>release</code>它。您使用特定于对象的Quartz 2D方法来保留和释放该对象。比如，如果你接收到一个CGColorSpace对象，你需要在合适的时候使用<code>CGColorSpaceRetain</code>和<code>CGColorSpaceRelease</code>方法去保留和释放该对象。你也可以使用Core Foundation提供的<code>CFRetain</code>和<code>CFRelease</code>方法，但是你必须要注意不要把NULL对象传给这些方法。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/11/一、Core-Graphics-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/一、Core-Graphics-Introduction/" itemprop="url">一、Core Graphics - Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T00:00:00+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Core Graphics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<h3 id="Introduction（介绍）"><a href="#Introduction（介绍）" class="headerlink" title="Introduction（介绍）"></a>Introduction（介绍）</h3><p>Core Graphics, also known as Quartz 2D, is an <code>advanced</code>, two-dimensional drawing engine <code>available for</code> iOS, tvOS and macOS application development. <code>Quartz 2D provides low-level, lightweight 2D rendering with unmatched output fidelity regardless of display or printing device.</code> Quartz 2D is resolution- and device-independent.</p>
<blockquote>
<p>Core Graphics（核心图形），也称为Quartz 2D，是一种<code>先进的</code>二维绘图引擎，<code>适用于</code>iOS，tvOS和macOS应用程序开发。<code>Quartz 2D提供低级，轻便的2D渲染，无与伦比的输出保真度，无论显示或打印设备如何。</code></p>
</blockquote>
<p>The Quartz 2D API is easy to use and <code>provides access to</code> powerful features such as transparency layers, path-based drawing, offscreen rendering, advanced color management, anti-aliased rendering, and PDF document creation, display, and parsing.</p>
<blockquote>
<p>Quartz 2D API易于使用，<code>可以访问</code>强大的功能，例如透明层，基于路径的绘图，屏幕外渲染，高级颜色管理，抗锯齿渲染和PDF文档创建，显示和解析。</p>
</blockquote>
<h3 id="Who-Should-Read-This-Document？（谁应该阅读这篇文档？）"><a href="#Who-Should-Read-This-Document？（谁应该阅读这篇文档？）" class="headerlink" title="Who Should Read This Document？（谁应该阅读这篇文档？）"></a>Who Should Read This Document？（谁应该阅读这篇文档？）</h3><p>This document <code>is intended for</code> developers who need to <code>perform</code> any of the following tasks:</p>
<ul>
<li>Draw graphics</li>
<li>Provide graphics editing <code>capabilities</code> in an application</li>
<li>Create or display bitmap images</li>
<li>Work with PDF documents<blockquote>
<p>本文档<code>面向</code>需要<code>执行</code>以下任务的开发人员：</p>
<ul>
<li>绘制图形</li>
<li>在应用程序中提供图形编辑<code>功能</code></li>
<li>创建或显示位图图像</li>
<li>使用PDF文档</li>
</ul>
</blockquote>
</li>
</ul>
<p>####Organization of This Document（该文档的组织结构）<br>This document is organized into the following chapters:</p>
<blockquote>
<p>本文档分为以下章节：</p>
</blockquote>
<ul>
<li><p>Overview of Quartz 2D describes the page, drawing destinations, Quartz opaque data types, graphics states, <code>coordinates</code>, and memory management, and it takes a look at how Quartz works <code>“under the hood.”</code></p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101" target="_blank" rel="noopener">Quartz 2D概述</a>介绍了页面，绘图目标，Quartz不透明数据类型，图形状态，<code>坐标</code>和内存管理，并介绍了Quartz如何在<code>“引擎盖”</code>下工作。</p>
</blockquote>
</li>
<li><p>Graphics Contexts describes the kinds of drawing destinations and provides step-by-step instructions for creating all flavors of graphics contexts.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-TPXREF101" target="_blank" rel="noopener">Graphics Contexts（图形上下文）</a>描述了绘图目的地的种类，并提供了创建各种图形上下文的分步说明。</p>
</blockquote>
</li>
<li><p>Paths discusses the basic elements that make up paths, shows how to create and paint them, shows how to set up a clipping area, and explains how blend modes affect painting.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-TPXREF101" target="_blank" rel="noopener">Paths（路径）</a>讨论组成路径的基本元素，显示如何创建和绘制它们，显示如何设置裁剪区域，以及解释混合模式如何影响绘画。</p>
</blockquote>
</li>
<li><p>Color and Color Spaces discusses color values and using alpha values for transparency, and it describes how to create a color space, set colors, create color objects, and set rendering intent.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101" target="_blank" rel="noopener">颜色和颜色空间（Color and Color Spaces）</a>讨论颜色值和使用Alpha值进行透明度，并介绍如何创建颜色空间，设置颜色，创建颜色对象和设置渲染意图。</p>
</blockquote>
</li>
<li><p>Transforms describes the current transformation matrix and explains how to modify it, shows how to set up affine transforms, shows how to convert between user and device space, and provides background information on the mathematical operations that Quartz performs.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_affine/dq_affine.html#//apple_ref/doc/uid/TP30001066-CH204-TPXREF101" target="_blank" rel="noopener">变换（Transforms）</a>描述当前的变换矩阵，并解释如何修改它，显示如何设置仿射变换，显示如何在用户和设备空间之间进行转换，并提供有关Quartz执行的数学运算的背景信息。</p>
</blockquote>
</li>
<li><p>Patterns defines what a pattern and its parts are, tells how Quartz renders them, and shows how to create colored and stenciled patterns.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_patterns/dq_patterns.html#//apple_ref/doc/uid/TP30001066-CH206-TPXREF101" target="_blank" rel="noopener">模式（Patterns）</a>定义了一个模式及其部分，说明了Quartz如何呈现它们，并展示了如何创建彩色和模板样式。</p>
</blockquote>
</li>
<li><p>Shadows describes what shadows are, explains how they work, and shows how to paint with them.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_shadows/dq_shadows.html#//apple_ref/doc/uid/TP30001066-CH208-TPXREF101" target="_blank" rel="noopener">阴影（Shadows）</a>描述了什么阴影，解释它们的工作原理，并展示如何用它们来绘制。</p>
</blockquote>
</li>
<li><p>Gradients discusses axial and radial gradients and shows how to create and use CGShading and CGGradient objects.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_shadings/dq_shadings.html#//apple_ref/doc/uid/TP30001066-CH207-TPXREF101" target="_blank" rel="noopener">梯度（Gradients）</a>讨论轴向和径向渐变，并显示如何创建和使用CGShading和CGGradient对象。</p>
</blockquote>
</li>
<li><p>Transparency Layers gives examples of what transparency layers look like, discusses how they work, and provides step-by-step instructions for implementing them.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_trans_layers/dq_trans_layers.html#//apple_ref/doc/uid/TP30001066-CH210-TPXREF101" target="_blank" rel="noopener">透明度层（Transparency Layers）</a>给出了透明层的外观，讨论了它们的工作原理，并提供了实现它们的分步说明。</p>
</blockquote>
</li>
<li><p>Data Management in Quartz 2D discusses how to move data into and out of Quartz.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101" target="_blank" rel="noopener">Quartz 2D中的数据管理（Data Management in Quartz 2D）</a>讨论了如何将数据移入和移出Quartz。</p>
</blockquote>
</li>
<li><p>Bitmap Images and Image Masks describes what makes up a bitmap image definition and shows how to use a bitmap image as a Quartz drawing primitive. It also describes masking techniques you can use on images and shows the various effects you can achieve by using blend modes when drawing images.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-TPXREF101" target="_blank" rel="noopener">位图图像和图像掩码（Bitmap Images and Image Masks）</a>描述了构成位图图像定义的内容，并展示了如何使用位图图像作为Quartz绘图图元。它还描述了可以在图像上使用的掩蔽技术，并显示了在绘制图像时使用混合模式可以实现的各种效果。</p>
</blockquote>
</li>
<li><p>Core Graphics Layer Drawing describes how to create and use drawing layers to achieve <code>high-performance</code> patterned drawing or to draw offscreen.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_layers/dq_layers.html#//apple_ref/doc/uid/TP30001066-CH219-TPXREF101" target="_blank" rel="noopener">核心图形图层（Core Graphics Layer Drawing）</a>描述了如何创建和使用绘图图层来实现<code>高性能</code>图案绘图或画外画。</p>
</blockquote>
</li>
<li><p>PDF Document Creation, Viewing, and Transforming shows how to open and view PDF documents, apply transforms to them, create a PDF file, access PDF metadata, add links, and add security features (such as password protection).</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_pdf/dq_pdf.html#//apple_ref/doc/uid/TP30001066-CH214-TPXREF101" target="_blank" rel="noopener">PDF文档创建，查看和转换（PDF Document Creation, Viewing, and Transforming）</a>显示如何打开和查看PDF文档，对其进行转换，创建PDF文件，访问PDF元数据，添加链接以及添加安全功能（如密码保护）。</p>
</blockquote>
</li>
<li><p>PDF Document Parsing describes how to use CGPDFScanner and CGPDFContentStream objects to parse and inspect PDF documents.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_pdf_scan/dq_pdf_scan.html#//apple_ref/doc/uid/TP30001066-CH220-TPXREF101" target="_blank" rel="noopener">PDF文档解析（PDF Document Parsing）</a>描述如何使用CGPDFScanner和CGPDFContentStream对象来分析和检查PDF文档。</p>
</blockquote>
</li>
<li><p>PostScript Conversion gives an overview of the functions you can use in Mac OS X to convert a PostScript file to a PDF document. These functions are not available in iOS.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_ps_convert/dq_ps_convert.html#//apple_ref/doc/uid/TP30001066-CH215-TPXREF101" target="_blank" rel="noopener">PostScript转换（PostScript Conversion）</a>概述了Mac OS X中可用于将PostScript文件转换为PDF文档的功能。 这些功能在iOS中不可用。</p>
</blockquote>
</li>
<li><p>Text describes Quartz 2D low-level support for text and glyphs, and alternatives that provide higher-level and Unicode text support. It also discusses how to copy font variations.</p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_text/dq_text.html#//apple_ref/doc/uid/TP30001066-CH213-TPXREF101" target="_blank" rel="noopener">文本（Text）</a>描述Quartz 2D对文本和字形的低级支持，以及提供更高级别和Unicode文本支持的替代方案。 它还讨论如何复制字体变体。</p>
</blockquote>
</li>
<li><p>Glossary defines the terms used in this guide. </p>
<blockquote>
<p><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/glossary/glossary.html#//apple_ref/doc/uid/TP30001066-CH221-SW7" target="_blank" rel="noopener">词汇表（Glossary）</a>定义本指南中使用的术语。</p>
</blockquote>
</li>
</ul>
<h3 id="也可以看看（See-Also）"><a href="#也可以看看（See-Also）" class="headerlink" title="也可以看看（See Also）"></a>也可以看看（See Also）</h3><p>These items are essential reading for anyone using Quartz 2D:</p>
<ul>
<li>Core Graphics Framework Reference provides a complete reference for the Quartz 2D application programming interface.</li>
<li>Color Management Overview is a brief introduction to the principles of color perception, color spaces, and color management systems.</li>
<li>Mailing lists. Join the quartz-dev mailing list to discuss problems using Quartz 2D.</li>
</ul>
<p>这些项目是使用Quartz 2D的人员必不可少的阅读材料：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/coregraphics" target="_blank" rel="noopener">Core Graphics Framework Reference</a>为Quartz 2D应用程序编程接口提供了完整的参考。</li>
<li><a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148" target="_blank" rel="noopener">颜色管理概述（Color Management Overview）</a>是对颜色感知，颜色空间和颜色管理系统原理的简要介绍。</li>
<li>邮寄名单 加入<a href="https://lists.apple.com/mailman/listinfo/quartz-dev" target="_blank" rel="noopener">quartz-dev</a>邮件列表来讨论使用Quartz 2D的问题。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/第十三篇、iOS的内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/01/第十三篇、iOS的内存管理/" itemprop="url">第十三篇、iOS的内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-01T00:00:00+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、MRC时代需要自己管理对象的释放，遵循谁创建谁释放的原则。"><a href="#1、MRC时代需要自己管理对象的释放，遵循谁创建谁释放的原则。" class="headerlink" title="1、MRC时代需要自己管理对象的释放，遵循谁创建谁释放的原则。"></a>1、MRC时代需要自己管理对象的释放，遵循谁创建谁释放的原则。</h4><h4 id="2、ARC时代程序自动管理内存，当一个对象的引用计数为0时，对象自动被释放。"><a href="#2、ARC时代程序自动管理内存，当一个对象的引用计数为0时，对象自动被释放。" class="headerlink" title="2、ARC时代程序自动管理内存，当一个对象的引用计数为0时，对象自动被释放。"></a>2、ARC时代程序自动管理内存，当一个对象的引用计数为0时，对象自动被释放。</h4><p>对于ARC来说，大部分情况下，都能很好地工作，但是在少部分情况下，由于代码的问题造成了一个对象的引用计数永远都不能为0，这样就会造成程序无法自动释放这个对象，就会造成内存泄漏。<br>比如：</p>
<blockquote>
<p>1.常见的循环引用。block，delegate。<br>2.底层的Core Foundation对象不在ARC的管理范畴之内，需要我们手动管理。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/30/CocoaAsyncSocket-Wiki-Intro-GCDAsyncSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/CocoaAsyncSocket-Wiki-Intro-GCDAsyncSocket/" itemprop="url">CocoaAsyncSocket - Wiki - Intro_GCDAsyncSocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T00:00:00+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS译文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://github.com/robbiehanson/CocoaAsyncSocket/wiki/Intro_GCDAsyncSocket" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<h3 id="GCDAsyncSocket简介"><a href="#GCDAsyncSocket简介" class="headerlink" title="GCDAsyncSocket简介"></a>GCDAsyncSocket简介</h3><p><strong>GCDAsyncSocket</strong>是一个TCP库。 它建在GCD之上。</p>
<p>该页提供了对这个库的介绍。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>The most common way to initialize an instance is simply like this:</code><br>初始化一个实例的最常用的方法是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = [[GCDAsyncSocket alloc] initWithDelegate:<span class="keyword">self</span> delegateQueue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure></p>
<p>为了让GCDAsyncSocket调用委托方法，必须使用delegate和delegate_queue。上面的代码指定了“self”作为委托，并指示库调用主线程上的所有委托方法。</p>
<p>设置代理可能是一个很熟悉的操作。然而，提供一个delegateQueue可能是一个心得概念。大多数典型的库都是单线程的。当调用委托方法的时候，他们只是调用它。这些库假设您的代理代码也是单线程的。或者库可能是内部的多线程，但是它们假设您的代理代码只是单线程的，并且只能在主线程上运行。所以他们总是在主线程上调用所有的委托方法。</p>
<p><code>GCDAsyncSocket, on the other hand, was designed for performance. It allows you to receive delegate callbacks on dedicated gcd queues of your choosing. This allows it to be used in high-performance servers, and can support thousands upon thousands of concurrent connections. But it also helps in typical applications. Want your UI to be a bit snappier? Ever considered moving that network processing code off the UI thread? Even today&#39;s mobile devices have multiple CPU cores... perhaps it&#39;s time to start taking advantage of them.</code><br>另一方面，GCDAsyncSocket是为性能而设计的。它允许您在您选择的专用gcd队列中接收委托回调。这允许它在高性能服务器中使用，并且可以支持成千上万的并发连接。但它也有助于典型应用。想要你的用户界面快点吗？曾经考虑过移动网络处理代码的UI线程？即使今天的移动设备有多个CPU内核，或许现在是开始利用它们的时候了。</p>
<h4 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h4><p>大多数情况下，无需配置。有各种配置选项（如头文件所述），但它们主要用于高级用例。</p>
<p>注意：安全（TLS / SSL）是您要稍后配置的。这些协议实际上运行在TCP之上（它们不是TCP本身的一部分）。</p>
<h4 id="连接（Connecting）"><a href="#连接（Connecting）" class="headerlink" title="连接（Connecting）"></a>连接（Connecting）</h4><p>最常见的连接方式是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (![socket connectToHost:<span class="string">@"deusty.com"</span> onPort:<span class="number">80</span> error:&amp;err]) <span class="comment">// Asynchronous!</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If there was an error, it's likely something like "already connected" or "no delegate set"</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I goofed: %@"</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>连接方法是异步的。什么意思？意思是当你调用连接方法时，它们开始后台操作连接到所需的主机/端口，然后立即返回。这个异步后台操作最终会成功或失败。无论哪种结果，都会调用相关联的委托方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sender didConnectToHost:(<span class="built_in">NSString</span> *)host port:(<span class="built_in">UInt16</span>)port</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Cool, I'm connected! That was easy."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以如果连接方法是异步的，它为什么会返回一个布尔值或者返回错误？只有一种情况这个方法会返回NO，就是如果明显有某些东西来阻止它启动连接操作。比如，如果socket已经连接好了，或者没有设置代理。</p>
<p>实际上有几种不同的连接方式可供你使用。 他们为您提供不同的选择，如：</p>
<ul>
<li>可以指定连接超时。<br><em>例如：如果在5秒内没有连接，就算失败</em></li>
<li>可以指定要连接的接口<br><em>例如：使用蓝牙连接，或使用WiFi连接，无论有线连接是否可用。</em></li>
<li>提供原始socket地址而不是名称/端口对<br><em>例如：我使用NSNetService解决了一个地址，我只想连接到该地址。</em></li>
</ul>
<h4 id="读-和-写"><a href="#读-和-写" class="headerlink" title="读 和 写"></a>读 和 写</h4><p>这个库的最佳功能之一是“队列化的读/写操作”。什么意思？一个快速的代码示例可以最好地解释它：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (![socket connectToHost:<span class="string">@"deusty.com"</span> onPort:<span class="number">80</span> error:&amp;err]) <span class="comment">// Asynchronous!</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// If there was an error, it's likely something like "already connected" or "no delegate set"</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I goofed: %@"</span>, err);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point the socket is NOT connected.</span></span><br><span class="line"><span class="comment">// But I can start writing to it anyway!</span></span><br><span class="line"><span class="comment">// The library will queue all my write operations,</span></span><br><span class="line"><span class="comment">// and after the socket connects, it will automatically start executing my writes!</span></span><br><span class="line">[socket writeData:request1 withTimeout:<span class="number">-1</span> tag:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// In fact, I know I have 2 requests.</span></span><br><span class="line"><span class="comment">// Why not just get them both out of the way now?</span></span><br><span class="line">[socket writeData:request2 withTimeout:<span class="number">-1</span> tag:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heck, while I'm at it, I might as well queue up the read for the first response.</span></span><br><span class="line">[socket readDataToLength:responseHeaderLength withTimeout:<span class="number">-1</span> tag:TAG_RESPONSE_HEADER];</span><br></pre></td></tr></table></figure></p>
<p>你可能注意到了<code>tag</code>参数。它是关于什么的呢？好，这一切都是为了方便你。你指定的<code>tag</code>参数并没有通过socket发送或者读取。<code>tag</code>参数只是通过各种委托方法回传给你。它旨在帮助简化代理方法中的代码。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(<span class="keyword">long</span>)tag</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"First request sent"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Second request sent"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当在读取时，Tags最为有用：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define TAG_WELCOME 10</span></span><br><span class="line"><span class="meta">#define TAG_CAPABILITIES 11</span></span><br><span class="line"><span class="meta">#define TAG_MSG 12</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sender didReadData:(<span class="built_in">NSData</span> *)data withTag:(<span class="keyword">long</span>)tag</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tag == TAG_WELCOME)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Ignore welcome message</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_CAPABILITIES)</span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">self</span> processCapabilities:data];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_MSG)</span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">self</span> processMessage:data];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Capabilities：功能</p>
</blockquote>
<p><code>You see, the TCP protocol is modeled on the concept of a single continuous stream of unlimited length.</code><br>您可以看到，TCP协议是以无限长度的<strong>单个连续流</strong>的概念建模的。<br>了解这一点至关重要 - 事实上，我们看到的这是<strong>造成困惑的第一原因</strong>。</p>
<p>想象一下你试着通过socket来发送一些信息。所以你像这样做(伪代码)：</p>
<blockquote>
<p>socket.write(“Hi Sandy.”);<br>socket.write(“Are you busy tonight?”);</p>
</blockquote>
<p>这些数据时如何在另一端展示的呢？如果您认为另一端将以两个单独的读取方式接收两个单独的句子，那么您刚好踩到了一个常见的坑。深呼吸！不要怕！你的状况并不是很糟糕；这只是一个常见的坑。通过阅读<a href="https://github.com/robbiehanson/CocoaAsyncSocket/wiki/CommonPitfalls" target="_blank" rel="noopener">Common Pitfalls</a>页面可以找到解决方法。</p>
<p>现在我们已经跳出了坑，你可能会想到这些读取方法。下面是少数几个方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)readDataToLength:(<span class="built_in">NSUInteger</span>)length withTimeout:(<span class="built_in">NSTimeInterval</span>)timeout tag:(<span class="keyword">long</span>)tag;</span><br><span class="line">- (<span class="keyword">void</span>)readDataToData:(<span class="built_in">NSData</span> *)data withTimeout:(<span class="built_in">NSTimeInterval</span>)timeout tag:(<span class="keyword">long</span>)tag;</span><br></pre></td></tr></table></figure></p>
<p>第一个方法，<code>readDataToLength</code>，通过给定的长度读取和返回数据。让我们看一个例子：</p>
<p>您正在编写协议的客户端，其中服务器以固定长度的头发送响应。所有的响应头正好是8个字节。前4个字节包含各种标志等。后4个字节包含响应数据的长度，是可变的。所以你可能像这样来编码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sender didReadData:(<span class="built_in">NSData</span> *)data withTag:(<span class="keyword">long</span>)tag</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tag == TAG_FIXED_LENGTH_HEADER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> bodyLength = [<span class="keyword">self</span> parseHeader:data];</span><br><span class="line">[socket readDataToLength:bodyLength withTimeout:<span class="number">-1</span> tag:TAG_RESPONSE_BODY];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_RESPONSE_BODY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Process the response</span></span><br><span class="line">[<span class="keyword">self</span> handleResponseBody:data];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start reading the next response</span></span><br><span class="line">[socket readDataToLength:headerLength withTimeout:<span class="number">-1</span> tag:TAG_FIXED_LENGTH_HEADER];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们来看看另外一个例子。毕竟，并不是所有的协议都使用固定长度的头。HTTP就是一种这样的协议。</p>
<p>一个典型的HTTP响应是像这样的：</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>Date: Thu, 24 Nov 2011 02:18:50 GMT<br>Server: Apache/2.2.3 (CentOS)<br>X-Powered-By: PHP/5.1.6<br>Content-Length: 5233<br>Content-Type: text/html; charset=UTF-8</p>
</blockquote>
<p>这只是一个例子。可能会有任何数量的header字段。换句话说，HTTP的头是一个可变的长度。我们怎么来理解它？</p>
<p>那么HTTP协议已经作了解释。header的每一行都是以CRLF(回车，换行：\r\n)来终止的。此外，header的末尾标有2个背对背CRLF。并且通过“Content-Length”头域指定body的长度。所以我们可以像这样做：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sender didReadData:(<span class="built_in">NSData</span> *)data withTag:(<span class="keyword">long</span>)tag</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tag == HTTP_HEADER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> bodyLength = [<span class="keyword">self</span> parseHttpHeader:data];</span><br><span class="line">[socket readDataToLength:bodyLength withTimeout:<span class="number">-1</span> tag:HTTP_BODY];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tag == HTTP_BODY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Process response</span></span><br><span class="line">[<span class="keyword">self</span> processHttpBody:data];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read header of next response</span></span><br><span class="line"><span class="built_in">NSData</span> *term = [<span class="string">@"\r\n\r\n"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">[socket readDataToData:term withTimeout:<span class="number">-1</span> tag:HTTP_HEADER];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我已经列出了两个可行的读取方法。有近10种不同的阅读方法。它们提供更高级的选项，例如指定maxLength，或提供您自己的读缓冲区。</p>
<h4 id="编写服务器（Writing-a-server）"><a href="#编写服务器（Writing-a-server）" class="headerlink" title="编写服务器（Writing a server）"></a>编写服务器（Writing a server）</h4><p>GCDAsyncSocket同时允许你创建一个服务器，然后接受将要到来的连接。它看起来是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">listenSocket = [[GCDAsyncSocket alloc] initWithDelegate:<span class="keyword">self</span> delegateQueue:dispatch_get_main_queue()];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (![listenSocket acceptOnPort:port error:&amp;error])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I goofed: %@"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)socket:(GCDAsyncSocket *)sender didAcceptNewSocket:(GCDAsyncSocket *)newSocket</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The "sender" parameter is the listenSocket we created.</span></span><br><span class="line"><span class="comment">// The "newSocket" is a new instance of GCDAsyncSocket.</span></span><br><span class="line"><span class="comment">// It represents the accepted incoming client connection.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do server stuff with newSocket...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是那么简单！如果想看更具体的例子，请参阅仓库随附的“EchoServer”示例项目。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/avatar.jpeg"
                alt="李乾" />
            
              <p class="site-author-name" itemprop="name">李乾</p>
              <p class="site-description motion-element" itemprop="description">人生不止眼前的苟且 还有诗和远方</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiamoon" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李乾</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
