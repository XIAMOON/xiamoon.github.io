<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:type" content="website">
<meta property="og:title" content="李乾的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="李乾的博客">
<meta property="og:description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李乾的博客">
<meta name="twitter:description" content="人生不止眼前的苟且 还有诗和远方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>李乾的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李乾的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海攻城狮一枚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/06/CollectionView的一些注意点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/06/CollectionView的一些注意点/" itemprop="url">CollectionView的一些注意点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-06T00:00:00+08:00">
                2018-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-创建collectionView后，需要调用registerClass-forCellWithReuseIdentifier-方法注册cell。这个方法类似于提前load-cell到内存中了，所以在cellForItem中只需要重用即可。"><a href="#1-创建collectionView后，需要调用registerClass-forCellWithReuseIdentifier-方法注册cell。这个方法类似于提前load-cell到内存中了，所以在cellForItem中只需要重用即可。" class="headerlink" title="1. 创建collectionView后，需要调用registerClass:forCellWithReuseIdentifier:方法注册cell。这个方法类似于提前load cell到内存中了，所以在cellForItem中只需要重用即可。"></a>1. 创建collectionView后，需要调用<code>registerClass:forCellWithReuseIdentifier:</code>方法注册cell。这个方法类似于提前load cell到内存中了，所以在<code>cellForItem</code>中只需要重用即可。</h4><h4 id="2-创建collectionView时，需要传入一个layout，然后指定layout的滚动方向，还有minimumItemSpacing，minimumLineSpacing。之所以是minimum，是因为。我们可以举个例子：minimumItemSpacing，即一行中cell的间距，而且所有item的间距都是相等的。当你指定一排的cell比较少时，只能拉开cell的间距来适配了，所以才是最小间距。即有可能比这个间距大。"><a href="#2-创建collectionView时，需要传入一个layout，然后指定layout的滚动方向，还有minimumItemSpacing，minimumLineSpacing。之所以是minimum，是因为。我们可以举个例子：minimumItemSpacing，即一行中cell的间距，而且所有item的间距都是相等的。当你指定一排的cell比较少时，只能拉开cell的间距来适配了，所以才是最小间距。即有可能比这个间距大。" class="headerlink" title="2. 创建collectionView时，需要传入一个layout，然后指定layout的滚动方向，还有minimumItemSpacing，minimumLineSpacing。之所以是minimum，是因为。我们可以举个例子：minimumItemSpacing，即一行中cell的间距，而且所有item的间距都是相等的。当你指定一排的cell比较少时，只能拉开cell的间距来适配了，所以才是最小间距。即有可能比这个间距大。"></a>2. 创建collectionView时，需要传入一个layout，然后指定layout的滚动方向，还有minimumItemSpacing，minimumLineSpacing。之所以是minimum，是因为。我们可以举个例子：minimumItemSpacing，即一行中cell的间距，而且所有item的间距都是相等的。当你指定一排的cell比较少时，只能拉开cell的间距来适配了，所以才是最小间距。即有可能比这个间距大。</h4><h4 id="3-对于minimumItemSpacing和minimumLineSpacing。"><a href="#3-对于minimumItemSpacing和minimumLineSpacing。" class="headerlink" title="3. 对于minimumItemSpacing和minimumLineSpacing。"></a>3. 对于minimumItemSpacing和minimumLineSpacing。</h4><p>如果是竖直方向滚动，那么minimumItemSpacing指代水平方向item的间距，minimumLineSpacing指代竖直方向<code>相邻两行</code>的间距。千万注意minimumLineSpacing不是指两个section的间距。</p>
<p>如果是水平方向滚动，那么minimumItemSpacing指代竖直方向item的间距，minimumLineSpacing指代水平方向<code>相邻两行</code>的间距。<br>比如要做一个水平的卡片滚动器，设置两个相邻卡片的距离需要设置minimumLineSpacing，而不是minimumItemSpacing，曾经被这个坑了差不多半个小时。</p>
<h4 id="4-自定义collectionViewCell"><a href="#4-自定义collectionViewCell" class="headerlink" title="4. 自定义collectionViewCell"></a>4. 自定义collectionViewCell</h4><p>collectionViewCell跟tableViewCell不同，在cellForRow中不需要判空。也就是说前者没有可以自定义的初始化方法。那么就只能依赖系统的自定义方法了。而且奇怪的是，我们只能用<code>initWithFrame:</code>方法，而不能用<code>init</code>方法。</p>
<blockquote>
<p>这里普及一个知识：当我们自定义一个MyView时，如果在获取这个view时使用[MyView new]或者[[MyView alloc] init]方法时，在MyView.m中，会先调用到<code>initWithFrame:</code>方法，后调用到<code>init</code>方法。但是如果是使用[[MyView alloc] initWithFrame:frame]方法，那么只会调用到<code>initWithFrame:</code>方法，而不会调用到<code>init</code>方法。<br>所以，我猜想自定义collectionViewCell时，系统在初始化cell时，使用的是上述中的后者。</p>
</blockquote>
<h4 id="5-滚动到指定位置"><a href="#5-滚动到指定位置" class="headerlink" title="5. 滚动到指定位置"></a>5. 滚动到指定位置</h4><p>滚动到指定位置可以使用<code>scrollToItemAtIndexPath: atScrollPosition: animated:</code>方法。其中ScrollPosition可以自定将要滚动到的cell在屏幕中的位置，可以指定：紧贴屏幕上边缘，居中和紧贴屏幕下边缘。当然这是对于竖直滚动方向的，水平滚动就是左中右了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/关于OC中extern的使用场景/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/关于OC中extern的使用场景/" itemprop="url">关于OC中extern的使用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T00:00:00+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般来说，我们如何定义一个全局变量以供其他类有权限使用它的值？</p>
<ol>
<li>在.h文件中定义一个属性，并且在.m文件中要赋值。</li>
<li>在.h文件中定义一个宏：#define。</li>
<li>用<code>extern</code>。</li>
</ol>
<blockquote>
<p>通常情况下，除非要创建一个类，一般我们不会使用方法<code>1</code>。<br>方法<code>2</code>也不用说了，很明白。</p>
</blockquote>
<h3 id="一、现在说一下方法3："><a href="#一、现在说一下方法3：" class="headerlink" title="一、现在说一下方法3："></a>一、现在说一下方法<code>3</code>：</h3><p><code>extern</code>表示变量可以被外部访问和赋值。<br>用法如下：<br>.h文件中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> accepterSendText;</span><br></pre></td></tr></table></figure></p>
<p>.m文件中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> accepterSendText = <span class="string">@"hi~我领到了你的愿望~"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、extern与-define的区别"><a href="#二、extern与-define的区别" class="headerlink" title="二、extern与#define的区别"></a>二、extern与#define的区别</h3><p><code>define</code>只是简单地替换，又称作宏定义、预处理命令。其不能保证在共享单例中取得一样的内存地址。<br><code>extern</code>会分配内存空间，提示编译器遇到此变量和函数时在其他模块寻找其定义。</p>
<blockquote>
<p>所以如果需要作为dictionary的key的话，使用extern NSString * const的写法，要比@””的写法（也就是用#define）更好。前者比较时用<code>isEqual:</code>就行了，直接比较地址；后者需要<code>isEqualToString:</code>即比较字符串的所有字符是否相等。</p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/gaoyuqiang30/article/details/48389369" target="_blank" rel="noopener">extern与define 区别</a></p>
<h3 id="三、OC中的FOUNDATION-EXTERN、FOUNDATION-EXPORT"><a href="#三、OC中的FOUNDATION-EXTERN、FOUNDATION-EXPORT" class="headerlink" title="三、OC中的FOUNDATION_EXTERN、FOUNDATION_EXPORT"></a>三、OC中的FOUNDATION_EXTERN、FOUNDATION_EXPORT</h3><p>这个其实跟extern、import差不多。不过OC中兼容了C和C++，见代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXTERN extern <span class="meta-string">"C"</span></span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXTERN extern</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if TARGET_OS_WIN32</span></span><br><span class="line"><span class="meta">#if defined(NSBUILDINGFOUNDATION)</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXPORT FOUNDATION_EXTERN __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#define FOUNDATION_IMPORT FOUNDATION_EXTERN __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define FOUNDATION_EXPORT  FOUNDATION_EXTERN</span></span><br><span class="line"><span class="meta">#define FOUNDATION_IMPORT FOUNDATION_EXTERN</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="四、引申：比较-”abc”和用NSString生成的abc"><a href="#四、引申：比较-”abc”和用NSString生成的abc" class="headerlink" title="四、引申：比较@”abc”和用NSString生成的abc"></a>四、引申：比较@”abc”和用NSString生成的abc</h3><p>写了一段代码测试：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"abc"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"abc"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str3 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str4 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"abc"</span>];</span><br><span class="line"><span class="built_in">NSMutableString</span> *str5 = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"a"</span>];</span><br><span class="line">[str5 appendString:<span class="string">@"bc"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^logString) (<span class="built_in">NSString</span> *str) = ^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&gt;&gt;&gt;%p, %p"</span>, &amp;str, str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logString(str1);</span><br><span class="line">logString(str2);</span><br><span class="line">logString(str3);</span><br><span class="line">logString(str4);</span><br><span class="line">logString(str5);</span><br></pre></td></tr></table></figure></p>
<p>log如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">0x16f623920</span>, <span class="number">0x100b18820</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0x16f623920</span>, <span class="number">0x100b18820</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0x16f623920</span>, <span class="number">0xa000000006362613</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0x16f623920</span>, <span class="number">0xa000000006362613</span></span><br><span class="line">&gt;&gt;&gt;<span class="number">0x16f623920</span>, <span class="number">0x107b2d880</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>str2与str1完全相同：编译器也警告：让我用声明str1的方式声明str2。</li>
<li>所有的字符串在内存中的地址都是一样的，也就是说，如果用<code>isEqual:</code>来比较的话他们都相等。</li>
<li>所以，用任何一种方法声明都可以。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/三、Core-Image-–-Auto-Enhancing-Image（自动增强图片）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/三、Core-Image-–-Auto-Enhancing-Image（自动增强图片）/" itemprop="url">三、Core Image – Auto Enhancing Image（自动增强图片）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T00:00:00+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Image/" itemprop="url" rel="index">
                    <span itemprop="name">Core Image</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用CIFliter</p>
<h3 id="一、Auto-Enhancement-Filters"><a href="#一、Auto-Enhancement-Filters" class="headerlink" title="一、Auto Enhancement Filters"></a>一、Auto Enhancement Filters</h3><table>
<thead>
<tr>
<th style="text-align:left">Filter</th>
<th style="text-align:left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CIRedEyeCorrection</td>
<td style="text-align:left">可以修复因相机闪光灯造成的红白眼</td>
</tr>
<tr>
<td style="text-align:left">CIFaceBalance</td>
<td style="text-align:left">调整面部的颜色，以使皮肤有愉悦的色调</td>
</tr>
<tr>
<td style="text-align:left">CIVibrance</td>
<td style="text-align:left">增加图像的饱和度而不扭曲皮肤的色调</td>
</tr>
<tr>
<td style="text-align:left">CIToneCurve</td>
<td style="text-align:left">调整图像的对比度</td>
</tr>
<tr>
<td style="text-align:left">CIHighlightShadowAdjust</td>
<td style="text-align:left">调整阴影细节</td>
</tr>
</tbody>
</table>
<h3 id="二、使用Auto-Enhancement-Filters"><a href="#二、使用Auto-Enhancement-Filters" class="headerlink" title="二、使用Auto Enhancement Filters"></a>二、使用Auto Enhancement Filters</h3><p>其API只有两个方法：<code>autoAdjustmentFilters</code>和<code>autoAdjustmentFiltersWithOptions:</code>。在大部分情况下，你会使用后者。</p>
<p>你可以设置一下选项：</p>
<ul>
<li>图像方向，这对<code>Auto Enhancement Filters</code>和<code>CIFaceBalance</code>滤镜是非常重要的，这样，Core Image就能准确地找到人脸。<br><br></li>
<li>是否只适用红眼矫正。(把<code>kCIImageAutoAdjustEnhance</code>设置为<code>false</code>)。<br><br></li>
<li>是否适用除红眼矫正外的所有滤镜。(把<code>kCIImageAutoAdjustRedEye</code>设置为false)。</li>
</ul>
<p><code>autoAdjustmentFiltersWithOptions:</code>方法返回一个数组选择过滤器，然后你会想把他们连锁在一起，应用于分析图像，如清单3所示。该代码首先创建一个选项字典。然后得到图像的方向，之后把方向设置为<code>CIDetectorImageOrientation</code>这个key的值。</p>
<p>如下为：获取自动增强的滤镜，然后把他们应用于图像<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123; <span class="built_in">CIDetectorImageOrientation</span> :</span><br><span class="line">[[image properties] valueForKey:kCGImagePropertyOrientation] &#125;;</span><br><span class="line"><span class="built_in">NSArray</span> *adjustments = [myImage autoAdjustmentFiltersWithOptions:options];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">CIFilter</span> *filter <span class="keyword">in</span> adjustments) &#123;</span><br><span class="line">[filter setValue:myImage forKey:kCIInputImageKey];</span><br><span class="line">myImage = filter.outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你不需要马上应用自动调整过滤器。稍后您可以保存过滤器名称和参数值。保存它们可以让你的应用程序在不需要再次分析图像的情况下执行增强功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/四、Core-Image-–-Querying-the-System-for-Filters（获取系统滤镜）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/四、Core-Image-–-Querying-the-System-for-Filters（获取系统滤镜）/" itemprop="url">四、Core Image – Querying the System for Filters（获取系统滤镜）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T00:00:00+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Image/" itemprop="url" rel="index">
                    <span itemprop="name">Core Image</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、获取滤镜和属性列表"><a href="#一、获取滤镜和属性列表" class="headerlink" title="一、获取滤镜和属性列表"></a>一、获取滤镜和属性列表</h3><p>使用<code>filterNamesInCategory:</code>和<code>filterNamesInCategories:</code>方法去精确发现可用的滤镜。滤镜是被分类的，使得列表更易于管理。使用后者时，你只需传入一个<code>nil</code>就可以获得所有分类的滤镜了。</p>
<p>一个滤镜可以是多个分类的成员，一个分类可以指定：</p>
<ul>
<li>滤镜所产生的效果(颜色调节、失真等)。见表4 - 1。</li>
<li>滤镜的使用(静态图像，视频，动态范围，等等)。见表4 - 2。</li>
<li>滤镜是否由核心图像(内置)提供。见表4 - 3。</li>
</ul>
<p><em>表4-1 效果类型对应的的过滤器类别常量</em><br>| 效果类型 | 解释 |<br>| :— | :— |<br>|kCICategoryDistortionEffect|扭曲效果，如bump, twirl, hole。|<br>|kCICategoryGeometryAdjustment|几何调整，如仿射变换、裁剪、透视变换。|<br>|kCICategoryCompositeOperation|合成, such as source over, minimum, source atop, color dodge blend mode<br>|<br>|kCICategoryHalftoneEffect|半色调效果，如屏幕，线屏，孵化。|<br>|kCICategoryColorAdjustment|调色，如伽玛调整，白点调整，曝光。|<br>|kCICategoryColorEffect|色彩效果，如色调调整，色调分离。|<br>|kCICategoryTransition|图像之间的转换，如溶解，与掩模的分离，滑动。|<br>|kCICategoryTileEffect|平铺效应，如平行四边形、三角形。|<br>|kCICategoryGenerator|图像发生器，如条纹，常色，棋盘格。|<br>|kCICategoryGradient|梯度，如轴向、径向、高斯分布。|<br>|kCICategoryStylize|如像素化，结晶化。|<br>|kCICategorySharpen|锐化，亮度。|<br>|kCICategoryBlur|模糊，如高斯，缩放，运动。|</p>
<p><em>表4-2 滤镜的使用对应的滤镜分类常量</em><br>| 使用 | 解释 |<br>| :— | :— |<br>|kCICategoryStillImage|用于静态图像|<br>|kCICategoryVideo|用于视频|<br>|kCICategoryInterlaced|用于交错图像|<br>|kCICategoryNonSquarePixels|用于非平方像素|<br>|kCICategoryHighDynamicRange|用于高动态范围像素，即：HDR|</p>
<p><em>表4-3 原始滤镜对应的滤镜分类常量</em><br>| 原始滤镜 | 解释 |<br>| :— | :— |<br>|kCICategoryBuiltIn|由 Core Image 提供的滤镜|</p>
<p>获取滤镜名称列表后，可以通过创建CIFilter对象并调用<code>attributes</code>方法来检索滤镜的属性：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIFilter</span> *myFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"&lt;# Filter Name Here #&gt;"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *myFilterAttributes = [myFilter attributes];</span><br></pre></td></tr></table></figure></p>
<p>Attributes包括例如：名称， 分类名， 类名，最小值，最大值。可以参考<a href="https://developer.apple.com/documentation/coreimage/cifilter?language=objc" target="_blank" rel="noopener">CIFilter Class Reference</a>。</p>
<h3 id="二、配置滤镜的属性字典"><a href="#二、配置滤镜的属性字典" class="headerlink" title="二、配置滤镜的属性字典"></a>二、配置滤镜的属性字典</h3><p>如果您的应用程序提供了一个用户界面，它可以查询一个滤镜的字典来创建和更新用户界面。例如，布尔值的滤镜属性需要一个复选框或类似的用户界面元素，而在一个范围内连续变化的属性可以使用一个滑块。您可以使用最大和最小值作为文本标签的基础。默认属性设置将指定用户界面中的初始设置。</p>
<p>滤镜名称和属性提供了构建用户界面所需的所有信息，用户界面允许用户选择筛选器并控制其输入参数。滤镜的属性告诉您滤镜有多少输入参数、参数名称、数据类型和最小值、最大值和默认值。</p>
<p>清单4-1显示了获取滤镜名称和根据功能类别构建滤镜字典的代码。代码从这些分类中检索滤镜—<code>kCICategoryGeometryAdjustment</code>、<code>kCICategoryDistortionEffect</code>、<code>kCICategorySharpen</code>和<code>kCICategoryBlur</code>—但是根据app-defined功能类别构建字典，如失真和焦点。功能类别对于在菜单中组织过滤器名称是有用的，这对用户来说是有意义的。代码不会遍历所有可能的核心图像筛选器类别，但您可以通过遵循相同的流程轻松地扩展此代码。</p>
<p><em>4-1 通过功能类别创建滤镜字典的代码</em><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *filtersByCategory = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *filterNames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">[filterNames addObjectsFromArray:</span><br><span class="line">[<span class="built_in">CIFilter</span> filterNamesInCategory:kCICategoryGeometryAdjustment]];</span><br><span class="line">[filterNames addObjectsFromArray:</span><br><span class="line">[<span class="built_in">CIFilter</span> filterNamesInCategory:kCICategoryDistortionEffect]];</span><br><span class="line">filtersByCategory[<span class="string">@"Distortion"</span>] = [<span class="keyword">self</span> buildFilterDictionary: filterNames];</span><br><span class="line"></span><br><span class="line">[filterNames removeAllObjects];</span><br><span class="line">[filterNames addObjectsFromArray:</span><br><span class="line">[<span class="built_in">CIFilter</span> filterNamesInCategory:kCICategorySharpen]];</span><br><span class="line">[filterNames addObjectsFromArray:</span><br><span class="line">[<span class="built_in">CIFilter</span> filterNamesInCategory:kCICategoryBlur]];</span><br><span class="line">filtersByCategory[<span class="string">@"Focus"</span>] = [<span class="keyword">self</span> buildFilterDictionary: filterNames];</span><br></pre></td></tr></table></figure></p>
<p>清单4-2显示了清单4-1所示的<code>buildFilterDictionary</code>例程。这个例程为函数类别中的每个滤镜构建一个属性字典。每一行代码的详细解释如下所示。</p>
<p><em>4-2 通过功能名称创建滤镜字典</em><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableDictionary</span> *)buildFilterDictionary:(<span class="built_in">NSArray</span> *)filterClassNames  <span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *filters = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *className <span class="keyword">in</span> filterClassNames) &#123;                         <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:className];             <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filter) &#123;</span><br><span class="line">filters[className] = [filter attributes];                       <span class="comment">// 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"could not create '%@' filter"</span>, className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> filters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>以一个滤镜名称数组作为输入参数。回想一下清单4-1，这个数组可以是多个Core Image筛选器类别中的滤镜名称的串联。在本例中，数组基于应用程序设置的功能类别(失真或焦点)。</li>
<li>遍历滤镜名称数组。</li>
<li>为滤镜名称获取滤镜对象。</li>
<li>检索滤镜的属性字典并将其添加到例程返回的字典中。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/二、Core-Image-–-Detecting-Faces-in-an-Image（在图片中检测人脸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/二、Core-Image-–-Detecting-Faces-in-an-Image（在图片中检测人脸/" itemprop="url">二、Core Image – Detecting Faces in an Image（在图片中检测人脸</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T00:00:00+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Image/" itemprop="url" rel="index">
                    <span itemprop="name">Core Image</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Core Image可以在图像中分析和发现人脸。它执行人脸检测，而不是识别。人脸检测是识别包含人脸特征的矩形，而人脸识别则是识别人脸(John, Mary，意思就是识别出不一样的人。等等)。当核心图像检测到人脸后，它可以提供人脸特征的信息，比如眼睛和嘴巴位置。它还可以在视频中追踪识别人脸的位置。</p>
<blockquote>
<p>注意：人脸检测不同于人脸识别。前者表示检测出是人脸的部分，包括眼睛、鼻子、嘴的位置，而后者表示识别出不同的人脸。后者的要求更高一些。<br><img src="/source/CI2_p_1.png" alt=""></p>
</blockquote>
<p>当你知道一张图片中人脸的位置之后，你可以做很多有趣的事情，比如裁减或者调整人脸部分。或者</p>
<ul>
<li>只把滤镜用于人脸部分，比如美颜。</li>
<li>在人脸附近添加贴纸。</li>
</ul>
<blockquote>
<p>注意：人脸检测只在iOS v5.0和OS X V10.7之后提供。</p>
</blockquote>
<h3 id="一、Detecting-Faces"><a href="#一、Detecting-Faces" class="headerlink" title="一、Detecting Faces"></a>一、Detecting Faces</h3><p>使用<code>CIDetector</code>类来进行人脸检测。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> context]; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *opts = @&#123;<span class="built_in">CIDetectorAccuracy</span> : <span class="built_in">CIDetectorAccuracyHigh</span>&#125;; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">CIDetector</span> *detector = [<span class="built_in">CIDetector</span> detectorOfType:<span class="built_in">CIDetectorTypeFace</span> context:context options:opts]; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *opts2 = @&#123;<span class="built_in">CIDetectorImageOrientation</span> : [[myImage properties] valueForKey:kCGImagePropertyOrientation]&#125;; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">NSArray</span> *features = [detector featuresInImage:myImage options:opts2];</span><br></pre></td></tr></table></figure></p>
<ol>
<li>创建带有默认选项的上下文。您可以使用在<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH3-TPXREF101" target="_blank" rel="noopener">Processing Image</a>中描述的任何上下文创建函数。当您创建检测器时，您还可以选择提供nil而不是context。</li>
<li>创建一个选项字典来指定检测器的精度。您可以指定低或高精确度。低准确度(CIDetectorAccuracyLow)是快速的;在本例中显示的高准确度是彻底的，但较慢。</li>
<li>为人脸创建一个检测器。你能创造出的唯一一种探测器是人脸。</li>
<li>设置一个查找faces的选项字典。让核心图像知道图像的方向是很重要的，这样探测器就知道在哪里可以找到直立的脸。大多数时候，您将从图像本身读取图像定位，然后将该值提供给options字典。</li>
<li>使用检测器查找图像中的特征。您提供的图像必须是一个CIImage对象。Core Image返回一个CIFeature对象数组，每个对象表示图像中的一张脸。</li>
</ol>
<p>在你得到一张脸的数组之后，你可能想要找出它们的特征，比如眼睛和嘴的位置。下一节将描述如何进行。</p>
<h3 id="二、Getting-Face-and-Face-Feature-Bounds"><a href="#二、Getting-Face-and-Face-Feature-Bounds" class="headerlink" title="二、Getting Face and Face Feature Bounds"></a>二、Getting Face and Face Feature Bounds</h3><p>脸部特征包括：</p>
<ul>
<li>左右眼的位置</li>
<li>嘴的位置</li>
<li>tracking ID和tracking帧数，用于Core Image跟踪视频片段中的人脸(可在iOS v6.0和稍后的OS X v10.8中使用)</li>
</ul>
<p>当您从一个<code>CIDetector</code>对象获得了一系列的面部特征后，您就可以遍历该数组以检查每个面的边界和每个特征。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">CIFaceFeature</span> *f <span class="keyword">in</span> features) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromRect</span>(f.bounds));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f.hasLeftEyePosition) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Left eye %g %g"</span>, f.leftEyePosition.x, f.leftEyePosition.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f.hasRightEyePosition) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Right eye %g %g"</span>, f.rightEyePosition.x, f.rightEyePosition.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f.hasMouthPosition) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Mouth %g %g"</span>, f.mouthPosition.x, f.mouthPosition.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/一、Core-Image-–-Processing-Images/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/一、Core-Image-–-Processing-Images/" itemprop="url">一、Core Image – Processing Images</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T00:00:00+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Image/" itemprop="url" rel="index">
                    <span itemprop="name">Core Image</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>意思就是使用滤镜。</li>
<li>需要用到<code>CIFilter</code>和<code>CIImage</code>类。</li>
<li>如果想创建自己的渲染工作流，需要用到<code>CIContext</code>类。</li>
</ol>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>对图片使用滤镜的基本方法：<br><em>The basics of applying a filter to an image</em><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import CoreImage</span><br><span class="line"></span><br><span class="line">let context = <span class="built_in">CIContext</span>()                                           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CISepiaTone"</span>)!                         <span class="comment">// 2</span></span><br><span class="line">filter.setValue(<span class="number">0.8</span>, forKey: kCIInputIntensityKey)</span><br><span class="line">let image = <span class="built_in">CIImage</span>(contentsOfURL: myURL)                           <span class="comment">// 3</span></span><br><span class="line">filter.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">let result = filter.outputImage!                                    <span class="comment">// 4</span></span><br><span class="line">let cgImage = context.createCGImage(result, from: result.extent)    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>创建<code>CIContext</code>对象。你并非每次都需要创建你自己的CIContext对象，通常，你可以集成其他的可以为你管理渲染过程的系统框架。使用自己的context可以让你更加精确地控制渲染过程和渲染所使用的资源。上下文(Context)是重量级的对象，如果你要使用它，那就尽早使用，并且在你每次想处理图片的时候重用它。</li>
<li>创建一个滤镜</li>
<li>通过一个URL创建一个<code>CIImage</code>对象</li>
<li>从filter中输出一个CIImage对象。此时，滤镜其实并没有开始执行—image对象是一个“配方”，指定如何使用指定的过滤器、参数和输入创建图像。<strong>Core Image 只有在请求呈现时执行此方法</strong>。</li>
<li>把输出图像渲染为一个<code>Core Graphics</code>图像，你可以把它展现出来或者村委一个文件。</li>
</ol>
</blockquote>
<h3 id="图像是滤镜的输入和输出"><a href="#图像是滤镜的输入和输出" class="headerlink" title="图像是滤镜的输入和输出"></a>图像是滤镜的输入和输出</h3><ol>
<li>一个<code>CIImage</code>对象是一个不可变对象，它代表着一个图片。这个对象并非直接代表图像的位图数据—相反，一个<code>CIImage</code>对象是一个生成图片的”配方”。一个配方可能是为了从一个文件中加载一个图片；另一个可能是为了代表滤镜的输出。Core Image只在您请求将图像呈现为显示或输出时执行这些方法。<br><br></li>
<li><p>您可以从几乎任何图像数据来源创建Core Image图像对象，包括：</p>
<blockquote>
<ul>
<li>引用着一个被加载的图片的URLs，或者包含图片文件数据的<code>NSData</code>对象。</li>
<li><code>CGImageRef</code>、<code>UIImage</code>或者<code>NSBitmapImageRep</code>对象。</li>
<li>Metal, OpenGL, or OpenGL ES textures，即纹理。</li>
<li>CoreVideo image or pixel buffers (<code>CVImageBufferRef</code>or <code>CVPixelBufferRef</code>)</li>
<li>IOSurfaceRef objects that share image data between processes</li>
<li>Image bitmap data in memory (a pointer to such data, or a CIImageProvider object that provides data on demand)</li>
</ul>
</blockquote>
</li>
<li><p>当你访问<code>CIFilter</code>的<code>outputImage</code>属性时，Core Image只是仅仅标识和存储执滤镜所需的步骤。这些步骤只在您请求将图像渲染出来去显示或输出时才真正执行。<br><br></p>
</li>
<li>只有当渲染时才处理图像使得Core Image快速高效。在呈现时，Core Image可以看到是否需要将多个滤镜应用于图像。如果是这样，它会自动连接多个“食谱”并组织它们以消除冗余操作，这样每个像素只处理一次而不是多次。</li>
</ol>
<p><code>CIFilter</code>的实例是可变对象，所以是非线程安全的，你不能在不同的线程中共享它。每个线程必须创建它自己的<code>CIFilter</code>对象。然而，一个filter的输入和输出的<code>CIFilter</code>对象是不可变的，所以可以线程共享。</p>
<h3 id="滤镜描述了图像处理效果"><a href="#滤镜描述了图像处理效果" class="headerlink" title="滤镜描述了图像处理效果"></a>滤镜描述了图像处理效果</h3><h4 id="把滤镜串联起来可以创建复杂的效果"><a href="#把滤镜串联起来可以创建复杂的效果" class="headerlink" title="把滤镜串联起来可以创建复杂的效果"></a>把滤镜串联起来可以创建复杂的效果</h4><ol>
<li>当串联了一系列的filter后，Core Image并非单个去执行这些filters，而是把这些filters重组在一起，最后高效的输出。<br>单独执行：<br><img src="/source/CI1_p_1.png" alt=""><br>重组为一个操作后执行：<br><img src="/source/CI1_p_2.png" alt=""><br>Core Image用的是后者，因为更快更搞笑。</li>
</ol>
<p>创建滤镜链：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func applyFilterChain(to image: <span class="built_in">CIImage</span>) -&gt; <span class="built_in">CIImage</span> &#123;</span><br><span class="line"><span class="comment">// The CIPhotoEffectInstant filter takes only an input image</span></span><br><span class="line">let colorFilter = <span class="built_in">CIFilter</span>(name: <span class="string">"CIPhotoEffectProcess"</span>, withInputParameters:</span><br><span class="line">[kCIInputImageKey: image])!</span><br><span class="line"></span><br><span class="line">let coloredImage = colorFilter.outputImage!</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass the result of the color filter into the Bloom filter</span></span><br><span class="line"><span class="comment">// and set its parameters for a glowy effect.</span></span><br><span class="line">let bloomImage = coloredImage!.applyingFilter(<span class="string">"CIBloom"</span>,</span><br><span class="line">withInputParameters: [</span><br><span class="line">kCIInputRadiusKey: <span class="number">10.0</span>,</span><br><span class="line">kCIInputIntensityKey: <span class="number">1.0</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// imageByCroppingToRect is a convenience method for</span></span><br><span class="line"><span class="comment">// creating the CICrop filter and accessing its outputImage.</span></span><br><span class="line">let cropRect = <span class="built_in">CGRect</span>(x: <span class="number">350</span>, y: <span class="number">350</span>, width: <span class="number">150</span>, height: <span class="number">150</span>)</span><br><span class="line">let croppedImage = bloomImage.cropping(to: cropRect)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> croppedImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用特殊的滤镜类型以获得更多选项"><a href="#使用特殊的滤镜类型以获得更多选项" class="headerlink" title="使用特殊的滤镜类型以获得更多选项"></a>使用特殊的滤镜类型以获得更多选项</h4><ol>
<li>大多数内置的滤镜的操作都是以一个图像作为输入，然后输出一个图像为主要过程。但是，系统也有一些其他类型的滤镜可以创造更有趣的效果，或者跟其他滤镜结合产出更复杂的效果。<blockquote>
<ul>
<li>一个混合滤镜可以通过一个预先设置的公式把两个图像结合。比如<blockquote>
<ul>
<li><code>CISourceInCompositing</code>滤镜可以结合图像，使得输出图像中只显示两个图像中都是不透明的部分。</li>
<li><code>CIMultiplyBlendMode</code>滤镜从两个图像中复制像素颜色，产生一个黑暗的输出图像。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>一个generator滤镜不需要输入图像。相反，这些滤镜使用其他的输入参数来从头创建一个新的图像。比如：<blockquote>
<ul>
<li><code>CIQRCodeGenerator</code>和<code>CICode128BarcodeGenerator</code>，这些滤镜可以通过指定的输入数据生成二维码图片。</li>
<li><code>CIConstantColorGenerator</code>，<code>CICheckboardGenerator</code>，<code>CILinerGradient</code>从指定的颜色生成简单的过程图像。你可以把这些跟其他滤镜结合起来创建更有趣的效果—比如<code>CIRadialGradient</code>滤镜可以为<code>CIMaskedVariableBlur</code>滤镜创建mask遮罩。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>一个reduction滤镜对输入图像进行操作，而不是在传统意义上创建输出图像，它的输出描述了关于输入图像的信息。<blockquote>
<ul>
<li><code>CIAreaMaximum</code></li>
<li><code>CIAreaHistogram</code></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>transition filter接受两个输入图像，并根据独立变量对它们的输出进行不同的输出。通常，这个变量是时间，所以您可以使用一个转换过滤器来创建一个<strong><code>动画</code></strong>，从一个图像开始，到另一个图像结束，然后使用一个有趣的视觉效果从一个到另一个。<blockquote>
<ul>
<li><code>CIDissolveTransition</code>滤镜</li>
<li><code>CICopyMachineTransition</code>滤镜</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="跟其他框架的集成"><a href="#跟其他框架的集成" class="headerlink" title="跟其他框架的集成"></a>跟其他框架的集成</h3><p>Core Image在iOS、macOS和tvOS中与其他几个技术交互。由于这种紧密的集成，您可以使用Core Image在您的应用程序的用户界面中轻松地添加视觉效果，而无需构建复杂的呈现代码。下面几节介绍了在应用程序中使用v的几种常见方法，以及每个应用程序的方便系统框架。</p>
<h4 id="在UIKit和AppKit中处理静态图像"><a href="#在UIKit和AppKit中处理静态图像" class="headerlink" title="在UIKit和AppKit中处理静态图像"></a>在UIKit和AppKit中处理静态图像</h4><p>UIKit和AppKit提供了一些简单的方法，可以将核心图像处理添加到静态图像中，无论这些图像出现在你的应用程序的UI中还是它的工作流的一部分。例如:</p>
<ul>
<li>旅行应用程序可以在列表中显示目的地的股票照片，然后将过滤器应用到这些图像中，为每个目的地的细节页面创建一个微妙的背景。</li>
<li>一个社交应用程序可以将过滤器应用到用户头像图片上，以显示每个帖子的情绪。</li>
<li>一个摄影应用程序可以允许用户在捕捉时使用滤镜自定义图像，或者为用户照片库中的图片添加图片应用扩展。(看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/Photos.html#//apple_ref/doc/uid/TP40014214-CH17" target="_blank" rel="noopener">Photo Editing</a>)<blockquote>
<p>注意：不要使用核心图像来创建模糊效果，因为不够高效和实时.</p>
</blockquote>
</li>
</ul>
<p>在iOS和tvOS中，你可以在任何<code>UIImage</code>对象上应用Core Image的滤镜。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CISepiaTone"</span>,</span><br><span class="line">withInputParameters: [kCIInputIntensityKey: <span class="number">0.5</span>])!</span><br><span class="line">@IBOutlet var imageView: <span class="built_in">UIImageView</span>!</span><br><span class="line"></span><br><span class="line">func displayFilteredImage(image: <span class="built_in">UIImage</span>) &#123;</span><br><span class="line"><span class="comment">// Create a Core Image image object for the input image.</span></span><br><span class="line">let inputImage = <span class="built_in">CIImage</span>(image: image)!</span><br><span class="line"><span class="comment">// Set that image as the filter's input image parameter.</span></span><br><span class="line">filter.setValue(inputImage, forKey: kCIInputImageKey)</span><br><span class="line"><span class="comment">// Get a UIImage representation of the filter's output and display it.</span></span><br><span class="line">imageView.image = <span class="built_in">UIImage</span>(<span class="built_in">CIImage</span>: filter.outputImage!)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用AVFoundation处理视频"><a href="#使用AVFoundation处理视频" class="headerlink" title="使用AVFoundation处理视频"></a>使用AVFoundation处理视频</h4><p>AVFoundation框架提供了一些用于视频和音频内容的高级实用程序。其中包括<code>AVVideoComposition</code>类，您可以使用它将视频和音频文件组合或编辑成一个单独的文件。您可以使用<code>AVVideoComposition</code>对象在播放或导出期间将Core Image的滤镜应用到视频的每一帧中。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CIGaussianBlur"</span>)!</span><br><span class="line">let composition = <span class="built_in">AVVideoComposition</span>(asset: asset, applyingCIFiltersWithHandler: &#123; request <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Clamp to avoid blurring transparent pixels at the image edges</span></span><br><span class="line">let source = request.sourceImage.clampingToExtent()</span><br><span class="line">filter.setValue(source, forKey: kCIInputImageKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vary filter parameters based on video timing</span></span><br><span class="line">let seconds = <span class="built_in">CMTimeGetSeconds</span>(request.compositionTime)</span><br><span class="line">filter.setValue(seconds * <span class="number">10.0</span>, forKey: kCIInputRadiusKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crop the blurred output to the bounds of the original image</span></span><br><span class="line">let output = filter.outputImage!.cropping(to: request.sourceImage.extent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide the filter output to the composition</span></span><br><span class="line">request.finish(with: output, context: <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示:清单1-4还展示了另一个有用的核心图像技术。默认情况下，模糊滤镜(blur filter)还可以通过模糊图像像素和透明像素(在过滤器的图像处理空间中)包围图像来软化图像的边缘。这种效果在某些情况下是不可取的，例如在过滤视频时。</p>
<p>为了避免这种效果，请使用<code>imageByClampingToScope</code>方法(或CIAffineClamp过滤器)在模糊前向所有方向无限扩展图像的边缘像素。夹紧创建一个无限大小的图像，所以你也应该在模糊后裁剪图像。</p>
</blockquote>
<h4 id="使用SpriteKit和SceneKit处理游戏内容"><a href="#使用SpriteKit和SceneKit处理游戏内容" class="headerlink" title="使用SpriteKit和SceneKit处理游戏内容"></a>使用SpriteKit和SceneKit处理游戏内容</h4><h4 id="在macOS中处理Core-Animation-Layers"><a href="#在macOS中处理Core-Animation-Layers" class="headerlink" title="在macOS中处理Core Animation Layers"></a>在macOS中处理Core Animation Layers</h4><h3 id="使用Core-Image-Context构建你自己的工作流"><a href="#使用Core-Image-Context构建你自己的工作流" class="headerlink" title="使用Core Image Context构建你自己的工作流"></a>使用Core Image Context构建你自己的工作流</h3><p>在前面的部分使用Core Image时，哪些框架或自动为我们管理好使用过程中的资源。然而，在某些情况下，使用<code>CIContext</code>类来管理这些资源更为谨慎。通过直接管理核心图像上下文，您可以精确地控制您的应用程序的性能特征，或者将核心图像与底层呈现技术集成在一起。</p>
<p>Core Image context用于执行筛选和生成图像所需的CPU或GPU计算技术、资源和设置。有几种上下文可供选择，因此您应该选择最适合您的应用程序工作流的选项，以及您可能正在使用的其他技术。下面的部分讨论一些常见的场景;</p>
<blockquote>
<p>重点：核心图像上下文是管理大量资源和状态的重量级对象。重复创建和销毁上下文具有很大的性能成本，因此，如果您计划执行多个图像处理操作，那么在早期创建一个上下文并存储它以备将来重用。</p>
</blockquote>
<h4 id="使用自动的Context来渲染呈现"><a href="#使用自动的Context来渲染呈现" class="headerlink" title="使用自动的Context来渲染呈现"></a>使用自动的Context来渲染呈现</h4><p>创建一个Core Image Context是很简单的：直接使用基本的<code>init</code>或者<code>initWithOptions:</code>初始化方法。当你创建之后，Core Image自动在内部管理你的资源，它会基于你当前的设备和你指定的options来选择最合适或者最佳的CPU或者GPU渲染技术。这种方法非常适合于将处理后的图像呈现给文件（例如，使用<code>writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:</code>方法）。</p>
<blockquote>
<p>注意:没有显式指定的上下文呈现目的地不能使用<code>drawImage:inRect:fromRect:</code>方法，因为该方法的行为变化取决于正在使用的渲染目的地。相反，使用方法名以<code>render</code>或者<code>create</code>开头的<code>CIContext</code>方法来指定明确的目的地。</p>
</blockquote>
<p>当你想实时的渲染Core Image的结果（例如：对过滤器参数进行动画修改，生成动画转换效果，或处理视频或其它已经每秒多次渲染的可视内容）。那么请谨慎使用此方法。尽管使用此方法创建的<code>CIContext</code>对象可以使用GPU自动呈现，但呈现所渲染的结果可能涉及CPU和GPU内存之间的昂贵的复制操作。</p>
<h4 id="使用Metal来实现实时的渲染"><a href="#使用Metal来实现实时的渲染" class="headerlink" title="使用Metal来实现实时的渲染"></a>使用Metal来实现实时的渲染</h4><p>Metal framework提供了对GPU的低开销访问，为图形呈现和并行计算工作流提供了高性能。这样的工作流是图像处理的一部分，所以Core Image尽可能地建立在Metal之上。如果你正在构建一个用Metal来渲染图形的应用程序，或者你想利用Metal来获得实时的动画效果，比如过滤输出或过滤动画输入(比如视频)，使用Metal设备来创建你的核心图像上下文。</p>
<p>下面的代码展示了使用MetalKit视图(MTKView)去渲染一个Core Image 的输出。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ViewController: <span class="built_in">UIViewController</span>, <span class="built_in">MTKViewDelegate</span> &#123;  <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Metal resources</span></span><br><span class="line">var device: <span class="built_in">MTLDevice</span>!</span><br><span class="line">var commandQueue: <span class="built_in">MTLCommandQueue</span>!</span><br><span class="line">var sourceTexture: <span class="built_in">MTLTexture</span>!                         <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Core Image resources</span></span><br><span class="line">var context: <span class="built_in">CIContext</span>!</span><br><span class="line">let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CIGaussianBlur"</span>)!</span><br><span class="line">let colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">device = <span class="built_in">MTLCreateSystemDefaultDevice</span>()            <span class="comment">// 3</span></span><br><span class="line">commandQueue = device.newCommandQueue()</span><br><span class="line"></span><br><span class="line">let view = <span class="keyword">self</span>.view as! <span class="built_in">MTKView</span>                   <span class="comment">// 4</span></span><br><span class="line">view.delegate = <span class="keyword">self</span></span><br><span class="line">view.device = device</span><br><span class="line">view.framebufferOnly = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">context = <span class="built_in">CIContext</span>(mtlDevice: device)             <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// other setup</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用OpenGL或者OpenGL-ES实现实时的渲染"><a href="#使用OpenGL或者OpenGL-ES实现实时的渲染" class="headerlink" title="使用OpenGL或者OpenGL ES实现实时的渲染"></a>使用OpenGL或者OpenGL ES实现实时的渲染</h4><p>Core Image也可以使用OpenGL来达到高性能的，基于GPU的渲染。如果你想支持更老的、<code>Metal</code>无法支持的硬件；或者如果你想把Core Image集成到一个已经存在的OpenGL或者OpenGL ES中，你可以使用这个选项。</p>
<ul>
<li>如果你想使用OpenGL ES，你可以使用<code>contextWithEAGLContext:options:</code>方法，配合你用来渲染的<code>EAGLContext</code>来初始化和创建一个Core Image上下文。</li>
</ul>
<p>在这两种场景中，使用<code>imageWithTexture:size:flipped:colorSpace:</code>方法从OpenGL或者OpenGL ES纹理中初始化创建<code>CIImage</code>对象。使用已经在GPU内存中的图像数据可以通过删除冗余的复制操作来提高性能。</p>
<p>为了能在OpenGL或者OpenGL ES中渲染一个Core Image的output，你得让你的GL context为current context，然后设置一个framebuffer，然后调用<code>drawImage:inRect:fromRect:</code>方法。</p>
<h4 id="使用Quartz-2D来实现基于CPU的渲染"><a href="#使用Quartz-2D来实现基于CPU的渲染" class="headerlink" title="使用Quartz 2D来实现基于CPU的渲染"></a>使用Quartz 2D来实现基于CPU的渲染</h4><p>如果你的app不需要实时的性能，然后使用CoreGraphic（比如，在UIKit或者APPKit的view里的<code>drawRect:</code>方法里 ），使用<code>contextWithCGContext:options:</code>初始化创建一个Core Image context，这个context会与你已经用来作其他绘制的Core Graphics context一起工作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/（开篇）Core-Image-–-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/（开篇）Core-Image-–-Introduction/" itemprop="url">（开篇）Core Image – Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T00:00:00+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Core-Image/" itemprop="url" rel="index">
                    <span itemprop="name">Core Image</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于Core-Image"><a href="#关于Core-Image" class="headerlink" title="关于Core Image"></a>关于Core Image</h3><p><code>Core Image</code>是一种图像分析和处理的技术，它被设计用来提供实时的图片和视频处理。它使用GPU或CPU渲染路径，从核心图形、核心视频和图像I/O框架中对图像数据类型进行操作。Core Image通过提供一个易于使用的应用程序编程接口(API)来隐藏底层图形处理的细节。您不需要知道OpenGL、OpenGL ES或Metal的详细信息就可以利用GPU的功能，也不需要了解关于Grand Central Dispatch (GCD)的任何信息，从而获得多核处理的好处。Core Image已经为您处理好了这些细节。</p>
<h3 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h3><p>Core Image框架提供：</p>
<ul>
<li>访问内置的图像处理滤镜</li>
<li>面部检测能力</li>
<li>支持自动图像增强</li>
<li>将多个过滤器链接在一起以创建自定义效果的能力</li>
<li>支持创建运行在GPU上的自定义滤镜</li>
<li>基于反馈的图像处理功能<blockquote>
<p>在macOS上，Core Image还提供了一种打包自定义滤镜的方法，供其他应用程序使用。</p>
</blockquote>
</li>
</ul>
<h4 id="核心图像是一种高效的、易用的图像处理和分析的框架"><a href="#核心图像是一种高效的、易用的图像处理和分析的框架" class="headerlink" title="核心图像是一种高效的、易用的图像处理和分析的框架"></a>核心图像是一种高效的、易用的图像处理和分析的框架</h4><p>Core Image提供了数百个内置过滤器。通过为滤镜的输入参数提供键值对来设置滤镜。一个滤镜的输出可以是另一个滤镜的输入，这样就可以将多个滤镜连接在一起，从而产生惊人的效果。如果您创建了一个您想要再次使用的复合效果，您可以子类化<code>CIFilter</code>来保留这个创建过程。</p>
<h4 id="创建和分发定制的内核和滤镜"><a href="#创建和分发定制的内核和滤镜" class="headerlink" title="创建和分发定制的内核和滤镜"></a>创建和分发定制的内核和滤镜</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/（六）《LearnOpenGL-CN》–-纹理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/（六）《LearnOpenGL-CN》–-纹理/" itemprop="url">（六）《LearnOpenGL CN》– 纹理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T00:00:00+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1-纹理坐标起始于-0-0-，也就是纹理图片的左下角，终始于-1-1-，即纹理图片的右上角。"><a href="#1-纹理坐标起始于-0-0-，也就是纹理图片的左下角，终始于-1-1-，即纹理图片的右上角。" class="headerlink" title="1. 纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。"></a>1. 纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。</h4><h4 id="2-就像顶点数据是：x-y-z-一样，纹理坐标是：s-t-r。"><a href="#2-就像顶点数据是：x-y-z-一样，纹理坐标是：s-t-r。" class="headerlink" title="2. 就像顶点数据是：x, y, z 一样，纹理坐标是：s, t, r。"></a>2. 就像顶点数据是：x, y, z 一样，纹理坐标是：s, t, r。</h4><p><br></p>
<h3 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h3><h4 id="1-纹理坐标的范围通常是从-0-0-到-1-1-，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择："><a href="#1-纹理坐标的范围通常是从-0-0-到-1-1-，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：" class="headerlink" title="1. 纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择："></a>1. 纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</h4><table>
<thead>
<tr>
<th style="text-align:left">环绕方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_REPEAT</td>
<td style="text-align:left">对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td style="text-align:left">GL_MIRRORED_REPEAT</td>
<td style="text-align:left">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td style="text-align:left">GL_CLAMP_TO_EDGE</td>
<td style="text-align:left">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td style="text-align:left">GL_CLAMP_TO_BORDER</td>
<td style="text-align:left">超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody>
</table>
<p><img src="/source/LOG6_p_1.png" alt=""></p>
<h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><h4 id="1-GL-NEAREST（也叫邻近过滤，Nearest-Neighbor-Filtering）是OpenGL默认的纹理过滤方式。当设置为GL-NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色："><a href="#1-GL-NEAREST（也叫邻近过滤，Nearest-Neighbor-Filtering）是OpenGL默认的纹理过滤方式。当设置为GL-NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：" class="headerlink" title="1. GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色："></a>1. GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</h4><p><img src="/source/LOG6_p_2.png" alt=""></p>
<h4 id="2-GL-LINEAR（也叫线性过滤，-Bi-linear-Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色："><a href="#2-GL-LINEAR（也叫线性过滤，-Bi-linear-Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：" class="headerlink" title="2. GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色："></a>2. GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</h4><p><img src="/source/LOG6_p_3.png" alt=""></p>
<h4 id="3-那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）："><a href="#3-那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：" class="headerlink" title="3. 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）："></a>3. 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</h4><p><img src="/source/LOG6_p_4.png" alt=""></p>
<blockquote>
<p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p>
</blockquote>
<h4 id="4-当进行放大-Magnify-和缩小-Minify-操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter-函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：我记得这个在CoreAnimation里面也有。"><a href="#4-当进行放大-Magnify-和缩小-Minify-操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter-函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：我记得这个在CoreAnimation里面也有。" class="headerlink" title="4. 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：我记得这个在CoreAnimation里面也有。"></a>4. 当进行<code>放大</code>(Magnify)和<code>缩小</code>(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：我记得这个在CoreAnimation里面也有。</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>
<h3 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h3><h4 id="1-多级渐远纹理是指，当你在看风景时，近处的风景肯定很清楚，分辨率非常高，而远处的风景可以很模糊，分辨率第一点也没问题，不会影响用户的感觉。"><a href="#1-多级渐远纹理是指，当你在看风景时，近处的风景肯定很清楚，分辨率非常高，而远处的风景可以很模糊，分辨率第一点也没问题，不会影响用户的感觉。" class="headerlink" title="1. 多级渐远纹理是指，当你在看风景时，近处的风景肯定很清楚，分辨率非常高，而远处的风景可以很模糊，分辨率第一点也没问题，不会影响用户的感觉。"></a>1. 多级渐远纹理是指，当你在看风景时，近处的风景肯定很清楚，分辨率非常高，而远处的风景可以很模糊，分辨率第一点也没问题，不会影响用户的感觉。</h4><blockquote>
<p>这一点用在OpenGL中可以节省内存占用和性能问题。</p>
</blockquote>
<h4 id="2-理论知识："><a href="#2-理论知识：" class="headerlink" title="2. 理论知识："></a>2. 理论知识：</h4><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：<br><img src="/source/LOG6_p_5.png" alt=""></p>
<h4 id="3-在渲染中切换多级渐远纹理级别-Level-时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式："><a href="#3-在渲染中切换多级渐远纹理级别-Level-时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：" class="headerlink" title="3. 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式："></a>3. 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</h4><table>
<thead>
<tr>
<th style="text-align:left">过滤方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_NEAREST_MIPMAP_NEAREST</td>
<td style="text-align:left">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td style="text-align:left">GL_LINEAR_MIPMAP_NEAREST</td>
<td style="text-align:left">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td style="text-align:left">GL_NEAREST_MIPMAP_LINEAR</td>
<td style="text-align:left">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td style="text-align:left">GL_LINEAR_MIPMAP_LINEAR</td>
<td style="text-align:left">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody>
</table>
<h4 id="4-就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一："><a href="#4-就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：" class="headerlink" title="4. 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一："></a>4. 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p>
</blockquote>
<h3 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h3><h4 id="1-使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如-PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。"><a href="#1-使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如-PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。" class="headerlink" title="1. 使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。"></a>1. 使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</h4><p>另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的stb_image.h库。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/（五）《LearnOpenGL-CN》–-着色器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/（五）《LearnOpenGL-CN》–-着色器/" itemprop="url">（五）《LearnOpenGL CN》– 着色器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T00:00:00+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <code>着色器</code>(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。<br><br></p>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="1-GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）："><a href="#1-GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）：" class="headerlink" title="1. GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）："></a>1. GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）：</h4><blockquote>
<p>类型    含义<br>vecn    包含n个float分量的默认向量<br>bvecn    包含n个bool分量的向量<br>ivecn    包含n个int分量的向量<br>uvecn    包含n个unsigned int分量的向量<br>dvecn    包含n个double分量的向量</p>
</blockquote>
<h4 id="2-一个向量的分量可以通过vec-x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用-x、-y、-z和-w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。"><a href="#2-一个向量的分量可以通过vec-x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用-x、-y、-z和-w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。" class="headerlink" title="2. 一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。"></a>2. 一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。</h4><p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p>
<blockquote>
<p>vec2 someVec;<br>vec4 differentVec = someVec.xyxx;<br>vec3 anotherVec = differentVec.zyw;<br>vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</p>
</blockquote>
<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><h4 id="1-虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。"><a href="#1-虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。" class="headerlink" title="1. 虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。"></a>1. 虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。</h4><p><br></p>
<h4 id="2-顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout-location-0-。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。"><a href="#2-顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout-location-0-。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。" class="headerlink" title="2. 顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。"></a>2. 顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。</h4><p><br></p>
<h4 id="3-片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。"><a href="#3-片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。" class="headerlink" title="3. 片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。"></a>3. 片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</h4><p><br></p>
<h4 id="4-所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。"><a href="#4-所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。" class="headerlink" title="4. 所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。"></a>4. 所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</h4><h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h3><h4 id="1-Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的-Global-。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。"><a href="#1-Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的-Global-。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。" class="headerlink" title="1. Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。"></a>1. Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</h4><blockquote>
<p>看起来像是一个全局的static变量。</p>
</blockquote>
<p>项目：</p>
<h4 id="1-实时更新颜色：uniform。设置执行main-cpp"><a href="#1-实时更新颜色：uniform。设置执行main-cpp" class="headerlink" title="1. 实时更新颜色：uniform。设置执行main.cpp"></a>1. 实时更新颜色：uniform。设置执行main.cpp</h4><p><a href="/source/LOG5_code_1.zip">代码下载</a></p>
<h3 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h3><h4 id="1-在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色："><a href="#1-在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：" class="headerlink" title="1.  在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色："></a>1.  在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">// 位置              // 颜色</span></span><br><span class="line"><span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右下</span></span><br><span class="line"><span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 左下</span></span><br><span class="line"><span class="number">0.0</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1："><a href="#2-由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1：" class="headerlink" title="2. 由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1："></a>2. 由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) <span class="keyword">in</span> vec3 aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line">layout (location = <span class="number">1</span>) <span class="keyword">in</span> vec3 aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> vec3 ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样："><a href="#3-因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：" class="headerlink" title="3. 因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样："></a>3. 因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：</h4><p><img src="/source/LOG5_p_1.png" alt=""></p>
<h4 id="项目：在顶点数组中加入颜色属性。设置执行main2-cpp"><a href="#项目：在顶点数组中加入颜色属性。设置执行main2-cpp" class="headerlink" title="项目：在顶点数组中加入颜色属性。设置执行main2.cpp"></a>项目：在顶点数组中加入颜色属性。设置执行main2.cpp</h4><p><a href="/source/LOG5_code_2.zip">代码下载</a></p>
<h3 id="编写自己的着色器类"><a href="#编写自己的着色器类" class="headerlink" title="编写自己的着色器类"></a>编写自己的着色器类</h3><h4 id="项目：设置执行main3-cpp"><a href="#项目：设置执行main3-cpp" class="headerlink" title="项目：设置执行main3.cpp"></a>项目：设置执行main3.cpp</h4><p><a href="/source/LOG5_code_3.zip">代码下载</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/（四）《LearnOpenGL-CN》–-你好，三角形/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/（四）《LearnOpenGL-CN》–-你好，三角形/" itemprop="url">（四）《LearnOpenGL CN》– 你好，三角形</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T00:00:00+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-OpenGL-CN/" itemprop="url" rel="index">
                    <span itemprop="name">Learn OpenGL CN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="1-顶点数组对象：Vertex-Array-Object，VAO"><a href="#1-顶点数组对象：Vertex-Array-Object，VAO" class="headerlink" title="1. 顶点数组对象：Vertex Array Object，VAO"></a>1. 顶点数组对象：Vertex Array Object，VAO</h5><p>顶点缓冲对象：Vertex Buffer Object，VBO<br>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO<br><br></p>
<h5 id="2-在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics-Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。"><a href="#2-在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics-Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。" class="headerlink" title="2. 在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。"></a>2. 在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。</h5><p><br></p>
<h5 id="3-2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕-窗口分辨率的限制。"><a href="#3-2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕-窗口分辨率的限制。" class="headerlink" title="3. 2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。"></a>3. 2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</h5><p><br></p>
<h5 id="4-图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器-Shader-。"><a href="#4-图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器-Shader-。" class="headerlink" title="4. 图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。"></a>4. 图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<code>着色器</code>(Shader)。</h5><p><br></p>
<h5 id="5-有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言-OpenGL-Shading-Language-GLSL-写成的，在下一节中我们再花更多时间研究它。"><a href="#5-有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言-OpenGL-Shading-Language-GLSL-写成的，在下一节中我们再花更多时间研究它。" class="headerlink" title="5. 有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。"></a>5. 有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</h5><p><br></p>
<h5 id="6-下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分"><a href="#6-下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分" class="headerlink" title="6. 下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分:"></a>6. 下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分:</h5><p><img src="/source/LOG4_p_1.png" alt=""></p>
<blockquote>
<p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧。</p>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。<br><strong>可以想想，任何一个几何图形，都能用一个三角形拼接而成，即三角形是能拼接成任何图形的最小单元</strong>。</p>
<p>图形渲染管线的第一个部分是<code>顶点着色器</code>(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p><code>图元装配</code>(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>
<p>图元装配阶段的输出会传递给<code>几何着色器</code>(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<p>几何着色器的输出会被传入<code>光栅化阶段</code>(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行<code>裁切</code>(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
<p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<code>Alpha测试和混合</code>(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查<code>alpha</code>值（alpha值定义了一个物体的透明度）并对物体进行<code>混合</code>(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。<br><strong>这最后一个阶段也是非常重要的，因为即使你计算出了颜色，但是如果它在另一个不透明的像素后面的话，那么这个颜色就应该被丢弃，如果它是透明的，那么还要跟它底部的颜色混合。</strong></p>
<p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<p>在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>
</blockquote>
<h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><h5 id="1-OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1-0到1-0的范围内时才处理它。所有在所谓的标准化设备坐标-Normalized-Device-Coordinates-范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。"><a href="#1-OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1-0到1-0的范围内时才处理它。所有在所谓的标准化设备坐标-Normalized-Device-Coordinates-范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。" class="headerlink" title="1. OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。"></a>1. OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</h5><p><br></p>
<h5 id="2-通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。"><a href="#2-通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。" class="headerlink" title="2. 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。"></a>2. 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</h5><p><br></p>
<h5 id="3-我们希望渲染一个三角形："><a href="#3-我们希望渲染一个三角形：" class="headerlink" title="3. 我们希望渲染一个三角形："></a>3. 我们希望渲染一个三角形：</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,</span><br><span class="line"><span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,</span><br><span class="line"><span class="number">0.0</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1-0到1-0的一小段空间。任何落在范围外的坐标都会被丢弃-裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形-忽略z轴-："><a href="#4-一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1-0到1-0的一小段空间。任何落在范围外的坐标都会被丢弃-裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形-忽略z轴-：" class="headerlink" title="4. 一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)："></a>4. 一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</h5><p><img src="/source/LOG4_p_2.png" alt=""></p>
<h5 id="5-定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。"><a href="#5-定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。" class="headerlink" title="5. 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。"></a>5. 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</h5><p><br></p>
<h5 id="6-我们通过顶点缓冲对象-Vertex-Buffer-Objects-VBO-管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。"><a href="#6-我们通过顶点缓冲对象-Vertex-Buffer-Objects-VBO-管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。" class="headerlink" title="6. 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。"></a>6. 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</h5><p><br></p>
<h5 id="7-顶点着色器就是把点的数组转化为在OpenGL窗口中的顶点。"><a href="#7-顶点着色器就是把点的数组转化为在OpenGL窗口中的顶点。" class="headerlink" title="7. 顶点着色器就是把点的数组转化为在OpenGL窗口中的顶点。"></a>7. <code>顶点着色器</code>就是把点的数组转化为在OpenGL窗口中的顶点。</h5><h5 id="8-片段着色器就是把光栅化之后的图像上色。即计算像素的颜色输出。"><a href="#8-片段着色器就是把光栅化之后的图像上色。即计算像素的颜色输出。" class="headerlink" title="8. 片段着色器就是把光栅化之后的图像上色。即计算像素的颜色输出。"></a>8. <code>片段着色器</code>就是把光栅化之后的图像上色。即计算像素的颜色输出。</h5><p><br></p>
<h5 id="9-要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样："><a href="#9-要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：" class="headerlink" title="9. 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样："></a>9. 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p>
</blockquote>
<h4 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h4><p>项目1：画三角形，无EBO <a href="/source/LOG4(画三角形，无EBO">代码下载</a>.zip)<br>项目2：画正方形，有EBO <a href="/source/LOG4(画正方形，有EBO">代码下载</a>.zip)<br>项目3：改变填充模式  <a href="/source/LOG4(改变填充模式">代码下载</a>.zip)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      


        
        <div>
        
        
        </div>
        


    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/avatar.jpeg"
                alt="李乾" />
            
              <p class="site-author-name" itemprop="name">李乾</p>
              <p class="site-description motion-element" itemprop="description">人生不止眼前的苟且 还有诗和远方</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiamoon" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李乾</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
