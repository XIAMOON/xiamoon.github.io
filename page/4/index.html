<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:type" content="website">
<meta property="og:title" content="李乾的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="李乾的博客">
<meta property="og:description" content="人生不止眼前的苟且 还有诗和远方">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李乾的博客">
<meta name="twitter:description" content="人生不止眼前的苟且 还有诗和远方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>李乾的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李乾的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">上海攻城狮一枚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/30/CocoaAsyncSocket-Wiki-CommonPitfalls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/CocoaAsyncSocket-Wiki-CommonPitfalls/" itemprop="url">CocoaAsyncSocket - Wiki - CommonPitfalls</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T00:00:00+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS译文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://github.com/robbiehanson/CocoaAsyncSocket/wiki/CommonPitfalls" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<h3 id="常见缺陷"><a href="#常见缺陷" class="headerlink" title="常见缺陷"></a>常见缺陷</h3><p><strong>常见缺陷 - 不要成为受害者</strong><br><code>Over the years we&#39;ve noticed that many issues arrise from general confusion about the TCP protocol. Arm yourself with knowledge so you don&#39;t lose time in the future.</code><br>多年来，我们注意到许多问题源于对TCP协议的一般混淆。用自己的知识掌握自己，以便将来不会失去时间。</p>
<h3 id="TCP是流"><a href="#TCP是流" class="headerlink" title="TCP是流"></a>TCP是流</h3><p><code>The TCP protocol is modeled on the concept of a single continuous stream of unlimited length. This is a very important concept to understand, and is the number one cause of confusion that we see.</code><br>TCP协议是以无限长度的<strong>单个连续流</strong>的概念建模的。这是一个非常重要的理解，是我们看到的<strong>第一个混乱的原因</strong>。</p>
<p>这到底是什么意思，它是如何影响开发人员的？</p>
<p>想像一下，您正试图通过socket发送一些消息。 所以你这样做（伪代码）：</p>
<blockquote>
<p>socket.write(“Hi Sandy.”);<br>socket.write(“Are you busy tonight?”);</p>
</blockquote>
<p><code>How does the data show up on the other end? If you think the other end will receive two separate sentences in two separate reads, then you&#39;ve just fallen victim to a common pitfall! Gasp! Read on.</code><br>数据如何显示在另一端？ 如果您认为另一端将以两个单独的读取方式接收两个单独的句子，那么您刚刚成为一个常见的陷阱的受害者！ 深呼吸！ 继续阅读。</p>
<p>TCP不将写作视为单独的数据。 TCP将所有写入视为单个连续流的一部分。所以当你发出上面的写入时，TCP将简单地将数据复制到缓冲区中：</p>
<blockquote>
<p>TCP_Buffer = “Hi Sandy.Are you busy tonight?”</p>
</blockquote>
<p>然后尽快发送数据。为了通过网络发送数据，TCP和其他网络协议将需要把该数据分割成可通过介质（以太网，WiFi等）传输的小块。<br>为了这样做，TCP可能以任何其认为合适的方式分解数据。 以下是一些数据可能被拆分和发送的示例：</p>
<ol>
<li>“Hi San” , “dy.Ar” , “e you “ , “busy to” , “night?”</li>
<li>“Hi Sandy.Are you busy” , “ tonight?”</li>
<li>“Hi Sandy.Are you busy tonight?”</li>
</ol>
<p>上述示例还演示了数据将如何到达另一端。我们来考虑一下例子1。</p>
<p>Sandy发出了一个socket.read()命令，并且正在等待数据到达。所以她第一次读取到的结果可能是“Hi San”。Sandy可能会开始处理这些数据。而当应用程序处理数据时，TCP流继续接收第二和第三个数据包。Sandy然后发出另一个socket.read()命令，这一次她得到“dy.Are you”。</p>
<p>这突出了TCP的连续流性质。TCP协议在开发人员API级别上绝对没有数据包或数据分离的概念。</p>
<p><code>But isn&#39;t this a major shortcoming? How do all those other protocols that use TCP work?</code><br>但这不是一个主要的缺点吗？所有使用TCP的其他协议如何工作？</p>
<p>HTTP是一个很好的例子，因为它很简单，因为大多数人都看过它。当客户端连接到服务器并发送请求时，它以非常具体的方式执行。它发送一个HTTP头，头部的每一行都用CRLF（回车符，换行符）终止。就像这样：</p>
<blockquote>
<p>GET /page.html HTTP/1.1<br>Host: google.com</p>
</blockquote>
<p><code>Since the protocol specifies the terminators, it is easy to read data from a TCP socket until the terminators are reached.</code><br>此外，HTTP标头的结尾用两个连续的CRLF发出信号。由于协议规定了终结器，因此很容易从TCP socket读取数据，直到达到终止符。</p>
<p>然后服务器发送响应：</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>Content-Length: 216</p>
</blockquote>
<blockquote>
<p>{ Exactly 216 bytes of data go here }</p>
</blockquote>
<p>再次，HTTP协议使得使用TCP变得容易。读取数据，直到您获得背靠背CRLF。 那是你的标题。然后从头解析内容长度，现在你可以简单地读取一定数量的字节。回到我们的原始示例，我们可以简单地使用指定的终止符来发送消息：</p>
<blockquote>
<p>socket.write(“Hi Sandy.\n”);<br>socket.write(“Are you busy tonight?\n”);</p>
</blockquote>
<p>而如果Sandy正在使用AsyncSocket，她会幸运的！因为AsyncSocket提供了真正易于使用的读取方法，允许您指定要查找的终止符。AsyncSocket为您提供其余的功能，并且会在两个单独的读取中提供两个单独的句子！</p>
<h3 id="写（Writes）"><a href="#写（Writes）" class="headerlink" title="写（Writes）"></a>写（Writes）</h3><p><strong>当您将数据写入TCP套接字时会发生什么？</strong>当写入完成时，是否意味着对方收到该数据？我们至少可以假定计算机已经发送了数据？ 答案是NO和NO。</p>
<p><code>Recall two things:</code><br>回想两件事情：</p>
<ul>
<li>发送和接收的所有数据必须分成小块，以便通过网络发送。</li>
<li>TCP处理许多复杂的问题，如重新发送丢失的数据包，并提供按顺序的传送，以便信息以正确的顺序到达。</li>
</ul>
<blockquote>
<p>a lot of <code>complicated</code> <code>issues</code>：许多<code>复杂的</code> <code>问题</code><br>providing <code>in-order</code> delivery：提供<code>按顺序的</code>传送</p>
</blockquote>
<p>因此，当您发出写入时，数据将被简单地复制到OS网络堆栈中的底层缓冲区中。在那一点上，TCP软件将开始其魔力，其中包括前面提到的所有酷的东西，如：</p>
<ul>
<li>将数据分成小块，以便可以通过网络发送数据</li>
<li>确保丢失的碎片得到适当的重发</li>
<li>确保您的数据以正确的顺序到达远程目标</li>
<li>提防网络拥塞</li>
<li>使用花式算法尽可能快地完成所有这些</li>
</ul>
<p>所以当你发出命令“写这个数据”时，操作系统会回应“我有你的数据，我将尽我力量把这个传递给远程目的地”。</p>
<p>但是<strong>我怎么知道远程目的地何时收到我的数据？</strong></p>
<p>这正是大多数人遇到问题的地方。下面有一个好的思考方式来理解它：</p>
<p>想象一下，你想给朋友发一封信。不是电子邮件，而是传统的慢邮。你知道，通过邮局。所以你写信并把它放在你的邮箱里。然后邮递员来了，拿走你的邮件。<code>You can rest assured at this point that the post office will make every effort to deliver the letter to your friend.</code>在这一点上你可以放心，邮局会竭尽全力把信交给你的朋友。但是如果你的朋友收到信件，你是怎么知道的？我想如果这封信回来了，盖上“返回发件人”，你可以肯定你的朋友没有收到。但是如果这封信没有回来呢？是否足以知道它已经投递到您朋友的邮箱？(假设这是一封非常非常重要的信。) 答案是否定的。可能这封信从来都没有被拿出过邮箱。也可能它的室友收到它然后意外地把它扔掉了。如果这个室友负责任，并把信留在你的朋友桌上？那够了吗？如果你的朋友在度假，你的信在一堆垃圾邮件中丢失了怎么办？所以真正知道你的朋友收到这封信的唯一方法是当你收到他的答复。</p>
<p>这是sockets的一个很好的比喻。当您将数据写入socket时，就像把信放在邮箱中。操作系统就像当地的邮递员一样，拿起这封信。将信件路由到目的地的巨型邮局系统就像网络。而向你的朋友邮箱中投递你的信的邮递员就像你的朋友的电脑上的操作系统。然后由朋友电脑上的应用程序读取操作系统中的数据并处理它（从邮箱中取出信件，并实际读取）。</p>
<p>那么如何知道远程目的地何时收到我的数据？这不是TCP可以告诉你的。最多只能告诉你，这封信已经提交给他们的邮箱。它不能告诉你应用程序是否读取该数据并进行处理。也许远端的应用程序崩溃了。或者也许远程用户在有机会读取数据之前退出应用程序。或者远程用户可能会遭受停电。这是篇长篇小说，如果需要，由应用层来回答这个问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/28/iOS新功能系列-iOS10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/iOS新功能系列-iOS10/" itemprop="url">iOS新功能系列 - iOS10</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T00:00:00+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS译文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p>本文总结了iOS 10中介绍的主要开发人员相关功能，这些功能在当前运送的iOS设备上运行。该文章还更详细地列出了描述新功能的文档。</p>
<p>有关已知问题的最新新闻和信息，请参见<a href="https://developer.apple.com/ios/download/上的发行说明。有关iOS" target="_blank" rel="noopener">https://developer.apple.com/ios/download/上的发行说明。有关iOS</a> 10中添加的新API的完整列表，请参阅<a href="https://developer.apple.com/library/content/releasenotes/General/iOS10APIDiffs/index.html" target="_blank" rel="noopener">iOS 10.0 API的差异</a>。有关新设备的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013599" target="_blank" rel="noopener">iOS设备兼容性参考</a>。</p>
<p>要了解Swift的新功能，请参阅<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/Chapters/Introduction.html#//apple_ref/doc/uid/TP40004635-SW3" target="_blank" rel="noopener">Swift语言</a>和<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="noopener">Swift编程语言（Swift 3.1）</a>。</p>
<h3 id="提供触觉反馈（Providing-Haptic-Feedback）"><a href="#提供触觉反馈（Providing-Haptic-Feedback）" class="headerlink" title="提供触觉反馈（Providing Haptic Feedback）"></a>提供触觉反馈（Providing Haptic Feedback）</h3><p>在iPhone 7和iPhone 7 Plus上，触觉提供了更多的方式来吸引用户的触觉反馈，从而吸引观众并强化行动。一些系统提供的界面元素，如选择器，开关和滑块，随着用户与它们的交互，自动提供触觉反馈。为了让您能够在面向iOS 10的应用程序中生成触觉，UIKit引入了新的UIFeedbackGenerator类和三个具体的子类，每个子类都支持适合特定场景的触觉，如表1所示。</p>
<p><strong>表1</strong> 具体的反馈发生器类和示例用法<br>| 类名 | 使用示例 |<br>|:—-|:—|<br>|UIImpactFeedbackGenerator|提供补充对动作或任务的视觉反馈的物理体验。例如，当视图滑动到位或两个对象碰撞时，用户可能会感到沮丧。|<br>|UINotificationFeedbackGenerator|表示一项任务或行动(例如存放支票或解锁车辆)已经完成，失败或产生某种类型的警告。|<br>|UISelectionFeedbackGenerator|表示选择正在主动更改。例如，当滚动拾取轮时，用户感觉到轻轻的点击。|</p>
<p>使用其中一个具体的子类，您可以要求系统为特定场景生成触觉，并根据您选择的场景管理反馈的强度和行为。此外，您可以调用<code>UIFeedbackGenerator</code>的<code>prepare</code>方法通知系统即将要求触觉反馈并最小化延迟。要了解如何使用触觉来提供应用程序中最佳的用户体验，请参阅<a href="https://developer.apple.com/ios/human-interface-guidelines/overview/design-principles/" target="_blank" rel="noopener">iOS人机交互指南</a>中的“触觉反馈”。</p>
<hr>
<h3 id="SiriKit"><a href="#SiriKit" class="headerlink" title="SiriKit"></a>SiriKit</h3><p>在特定领域中提供服务的应用程序可以使用SiriKit来使这些服务可以在iOS的Siri上提供。使您的服务可用需要使<code>Intents</code>和<code>Intents UI frameworks</code>创建一个或多个应用程序扩展。SiriKit支持以下领域的服务：</p>
<blockquote>
<p>domains：域名、领域</p>
</blockquote>
<ul>
<li>音频或视频通话</li>
<li>消息</li>
<li>发起或接收付款</li>
<li>搜索照片</li>
<li>骑行预订</li>
<li>管理锻炼</li>
<li>在启用CarPlay的车辆中调整设置（仅限汽车供应商）</li>
<li>预订餐厅（需要苹果的额外支持）</li>
</ul>
<p><code>When the user makes a request involving your service, SiriKit sends your extension an intent object, which describes the user’s request and provides any data related to that request. You use the intent object to provide an appropriate response object, which includes details of how you can handle the user’s request. Siri typically handles all user interactions, but you can use an extension to provide custom UI that incorporates branding or additional information from your app.</code><br>当用户提出涉及您的服务的请求时，SiriKit将您的扩展名发送到一个intent对象，该对象描述用户的请求，并提供与该请求相关的任何数据。您使用intent对象来提供适当的响应对象，其中包含如何处理用户请求的详细信息。Siri通常处理所有用户交互，但您可以使用扩展程序来提供自定义UI，其中包含来自您的应用程序的品牌或附加信息。</p>
<p><code>SiriKit also provides a mechanism you can use to tell the system about the interactions and activities that occur within your app. SiriKit defines an interaction object, which combines an intent with information about the intent-handling process, including details such as the start time and duration of a specific occurrence of the process. If your app is registered as capable of handling an activity that has the same name as an intent, the system can launch your app with an interaction object containing that intent even if you don’t provide an Intents app extension.</code><br>SiriKit还提供了一种机制，可用于告诉系统有关应用程序中发生的交互和活动。SiriKit定义了一个交互对象，它将意图与意图处理过程的信息相结合，包括特定事件发生的开始时间和持续时间等细节。如果您的应用程序注册为能够处理与意图相同名称的活动，则即使您没有提供Intents应用程序扩展名，系统也可以使用包含该意图的交互对象启动应用。</p>
<p><code>Ride booking is supported by both Maps and Siri, and users can also make restaurants reservations with Maps. Your Intents extension handles interactions that originate from the Maps app in the same way that it handles requests coming from Siri. If you customize the user interface, your Intents UI extension can also configure itself differently, depending on whether the request came from Siri or Maps.</code><br>地图和Siri都支持骑行预订，用户还可以使用Google地图预订餐厅。您的Intents扩展程序以与处理来自Siri的请求相同的方式处理来自Maps应用程序的交互。如果您自定义用户界面，则Intents UI扩展还可以以不同方式进行配置，具体取决于请求是来自Siri还是Maps。</p>
<p>要了解如何支持SiriKit并为用户提供访问您的服务的新方法，请阅读<a href="https://developer.apple.com/library/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html#//apple_ref/doc/uid/TP40016875" target="_blank" rel="noopener">SiriKit编程指南</a>。当您准备好实现处理各种意图的应用程序扩展时，请参阅<a href="https://developer.apple.com/reference/intents" target="_blank" rel="noopener">Intents Framework Reference</a>和<a href="https://developer.apple.com/reference/intentsui" target="_blank" rel="noopener">Intents UI Framework Reference</a>。</p>
<h3 id="积极的建议（Proactive-Suggestions）"><a href="#积极的建议（Proactive-Suggestions）" class="headerlink" title="积极的建议（Proactive Suggestions）"></a>积极的建议（Proactive Suggestions）</h3><p><code>iOS 10 introduces new ways to increase engagement with your app by helping the system suggest your app to users at appropriate times. If you adopted app search in your iOS 9 app, you gave users access to activities and content deep within your app through Spotlight and Safari search results, Handoff, and Siri suggestions. In iOS 10 and later, you can provide information about what users do in your app, which helps the system promote your app in additional places, such as the keyboard with QuickType suggestions, Maps and CarPlay, the app switcher, Siri interactions, and (for media playing apps) the lock screen. These opportunities for enhanced integration with the system are supported by a collection of technologies, such as NSUserActivity, web markup defined by Schema.org, and APIs defined in the Core Spotlight, MapKit, UIKit, and Media Player frameworks.</code><br>iOS 10通过帮助系统在适当的时间向用户建议您的应用，引入了新的方式来增加与您的应用的互动。如果您在iOS 9应用程序中采用了应用程序搜索，则可以通过Spotlight和Safari搜索结果，Handoff和Siri建议，让用户访问您应用程序内的活动和内容。在iOS 10及更高版本中，您可以提供有关用户在应用中执行的操作的信息，这有助于系统在其他地方宣传您的应用，例如带有QuickType建议的键盘，地图和CarPlay，应用切换器，Siri互动和（ 用于媒体播放应用程序）锁屏。这些增强与系统集成的机会得到了诸如NSUserActivity，由Schema.org定义的Web标记以及Core Spotlight，MapKit，UIKit和Media Player框架中定义的API等技术的支持。<br>…</p>
<h3 id="与消息应用程序集成（Integrating-with-the-Messages-App）"><a href="#与消息应用程序集成（Integrating-with-the-Messages-App）" class="headerlink" title="与消息应用程序集成（Integrating with the Messages App）"></a>与消息应用程序集成（Integrating with the Messages App）</h3><p>…</p>
<h3 id="用户通知（User-Notifications）"><a href="#用户通知（User-Notifications）" class="headerlink" title="用户通知（User Notifications）"></a>用户通知（User Notifications）</h3><p>iOS 10引入了用户通知框架（UserNotifications.framework），它支持本地和远程通知的传递和处理。您可以使用此框架的类根据特定条件（如时间或位置）安排本地通知的传递。应用程序和应用程序扩展可以使用此框架在本地和远程通知传递到用户的设备时接收并潜在地进行修改。</p>
<p>还在iOS 10中引入了用户通知UI框架（UserNotificationsUI.framework），您可以在用户设备上显示本地和远程通知时自定义外观。您可以使用此框架定义一个应用程序扩展，它接收通知数据并提供相应的可视化表示。您的扩展程序还可以响应与这些通知相关联的自定义操作。</p>
<h3 id="语音识别（Speech-Recognition）"><a href="#语音识别（Speech-Recognition）" class="headerlink" title="语音识别（Speech Recognition）"></a>语音识别（Speech Recognition）</h3><p>…</p>
<h3 id="更多的颜色（Wide-Color）"><a href="#更多的颜色（Wide-Color）" class="headerlink" title="更多的颜色（Wide Color）"></a>更多的颜色（Wide Color）</h3><p>…</p>
<h3 id="适应真实色调显示（Adapting-to-the-True-Tone-Display）"><a href="#适应真实色调显示（Adapting-to-the-True-Tone-Display）" class="headerlink" title="适应真实色调显示（Adapting to the True Tone Display）"></a>适应真实色调显示（Adapting to the True Tone Display）</h3><p>…</p>
<h3 id="应用搜索增强功能（App-Search-Enhancements）"><a href="#应用搜索增强功能（App-Search-Enhancements）" class="headerlink" title="应用搜索增强功能（App Search Enhancements）"></a>应用搜索增强功能（App Search Enhancements）</h3><p>…</p>
<h3 id="小部件增强功能（Widget-Enhancements）"><a href="#小部件增强功能（Widget-Enhancements）" class="headerlink" title="小部件增强功能（Widget Enhancements）"></a>小部件增强功能（Widget Enhancements）</h3><p>…</p>
<h3 id="应用搜索增强功能（App-Search-Enhancements）-1"><a href="#应用搜索增强功能（App-Search-Enhancements）-1" class="headerlink" title="应用搜索增强功能（App Search Enhancements）"></a>应用搜索增强功能（App Search Enhancements）</h3><p>…</p>
<h3 id="苹果付费增强（Apple-Pay-Enhancements）"><a href="#苹果付费增强（Apple-Pay-Enhancements）" class="headerlink" title="苹果付费增强（Apple Pay Enhancements）"></a>苹果付费增强（Apple Pay Enhancements）</h3><p>…</p>
<h3 id="安全和隐私增强（Security-and-Privacy-Enhancements）"><a href="#安全和隐私增强（Security-and-Privacy-Enhancements）" class="headerlink" title="安全和隐私增强（Security and Privacy Enhancements）"></a>安全和隐私增强（Security and Privacy Enhancements）</h3><p>…</p>
<h3 id="CallKit（CallKit）"><a href="#CallKit（CallKit）" class="headerlink" title="CallKit（CallKit）"></a>CallKit（CallKit）</h3><p>…</p>
<h3 id="视频订阅者帐户（Video-Subscriber-Account）"><a href="#视频订阅者帐户（Video-Subscriber-Account）" class="headerlink" title="视频订阅者帐户（Video Subscriber Account）"></a>视频订阅者帐户（Video Subscriber Account）</h3><p>…</p>
<h3 id="应用扩展（App-Extensions）"><a href="#应用扩展（App-Extensions）" class="headerlink" title="应用扩展（App Extensions）"></a>应用扩展（App Extensions）</h3><p>…</p>
<h3 id="额外的框架更改（Additional-Framework-Changes）"><a href="#额外的框架更改（Additional-Framework-Changes）" class="headerlink" title="额外的框架更改（Additional Framework Changes）"></a>额外的框架更改（Additional Framework Changes）</h3><h4 id="AVFoundation相机拍摄（AVFoundation-Camera-Capture）"><a href="#AVFoundation相机拍摄（AVFoundation-Camera-Capture）" class="headerlink" title="AVFoundation相机拍摄（AVFoundation Camera Capture）"></a>AVFoundation相机拍摄（AVFoundation Camera Capture）</h4><h4 id="双摄像头和设备发现（Dual-Camera-and-Device-Discovery）"><a href="#双摄像头和设备发现（Dual-Camera-and-Device-Discovery）" class="headerlink" title="双摄像头和设备发现（Dual Camera and Device Discovery）"></a>双摄像头和设备发现（Dual Camera and Device Discovery）</h4><h4 id="新的Photo-Capture-API（New-Photo-Capture-API）"><a href="#新的Photo-Capture-API（New-Photo-Capture-API）" class="headerlink" title="新的Photo Capture API（New Photo Capture API）"></a>新的Photo Capture API（New Photo Capture API）</h4><p>新的<a href="https://developer.apple.com/reference/avfoundation/avcapturephotooutput" target="_blank" rel="noopener">AVCapturePhotoOutput</a>类为所有摄影工作流程提供了统一的管道，可以对整个捕获过程进行更为复杂的控制和监控，并支持Live Feature和RAW格式捕获等新功能。您应该转换到<a href="https://developer.apple.com/reference/avfoundation/avcapturestillimageoutput" target="_blank" rel="noopener">AVCapturePhotoOutput</a>而不是AVCaptureStillImageOutput，这在iOS 10中已被弃用。</p>
<h4 id="更多的颜色（Wide-Color）-1"><a href="#更多的颜色（Wide-Color）-1" class="headerlink" title="更多的颜色（Wide Color）"></a>更多的颜色（Wide Color）</h4><h4 id="AVFoundation媒体（AVFoundation-Media）"><a href="#AVFoundation媒体（AVFoundation-Media）" class="headerlink" title="AVFoundation媒体（AVFoundation Media）"></a>AVFoundation媒体（AVFoundation Media）</h4><p>AVFoundation框架（AVFoundation.framework）中的媒体播放和编辑子系统包括以下增强功能：</p>
<ul>
<li>您不再需要为AVPlayerItem实现不同的行为，具体取决于内容是电影文件还是HLS内容。在iOS 10之间或之后连接的应用程序中，您只需设置速率属性，AVFoundation就可以确定何时有足够的内容被缓冲播放而不停顿。</li>
<li><a href="https://developer.apple.com/reference/avfoundation/avplayerlooper" target="_blank" rel="noopener">AVPlayerLooper</a>类可以在播放过程中更容易地循环播放特定的媒体内容。</li>
<li>使用<a href="https://developer.apple.com/reference/avfoundation/avassetdownloadurlsession" target="_blank" rel="noopener">VAssetDownloadURLSession</a>类将asset（包括HLS流）下载到设备，然后稍后再播放。当与FairPlay Streaming一起使用时，您可以下载加密的HLS流，并在以后安全地播放流。</li>
</ul>
<h4 id="AVKit（AVKit）"><a href="#AVKit（AVKit）" class="headerlink" title="AVKit（AVKit）"></a>AVKit（AVKit）</h4><p>AVKit框架（AVKit.framework）包含updatesNowPlayingInfoCenter属性，该属性指示何时更新“正在播放信息中心”。</p>
<h4 id="Core-Data（Core-Data）"><a href="#Core-Data（Core-Data）" class="headerlink" title="Core Data（Core Data）"></a>Core Data（Core Data）</h4><h4 id="核心图像（Core-Image）"><a href="#核心图像（Core-Image）" class="headerlink" title="核心图像（Core Image）"></a>核心图像（Core Image）</h4><p>Core Image框架（CoreImage.framework）包含几个增强功能。现在可以在使用A8或A9 CPU的iOS设备上使用RAW图像文件支持。核心图像可以解码多个第三方摄像机生成的RAW图像以及由支持的iOS设备的iSight摄像机生成的图像（了解更多信息，请参阅<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW2" target="_blank" rel="noopener">AVFoundation</a>）。要处理RAW图像，请使用<code>filterWithImageData：options：</code>或<code>filterWithImageURL：options：</code>创建CIFilter对象，使用<code>RAW Image Options</code>中列出的键调整RAW处理选项，并从过滤器的<code>outputImage</code>属性读取已处理的图像。</p>
<p>现在可以使用<code>imageWithExtent</code>将参数插入到Core Image过滤器图中：<code>processorDescription：argumentDigest：inputFormat：outputFormat：options：roiCallback：processor：method</code>。<br>该方法在处理用于显示或输出的图像时，添加Core Image在过滤器之间调用的回调块；在block中，您可以访问包含处理后图像的当前状态的像素缓冲区或金属纹理，并应用自己的图像处理算法。</p>
<p>使用自定义处理器block或编写过滤器内核时，可以处理除Core Image上下文的工作颜色空间之外的颜色空间中的图像。使用<code>imageByColorMatchingWorkingSpaceToColorSpace：</code>和<code>imageByColorMatchingColorSpaceToWorkingSpace：</code>在处理之前和之后转换成颜色空间的方法。</p>
<p>在UIImageView对象中渲染由Core Image映像（例如使用<code>initWithCIImage：initializer</code>创建的那些）支持的UIImage对象，性能显着提高。另外，使用宽色域颜色配置文件标记的Core Image-Support UIImage对象呈现在使用宽色域颜色的UIImageView对象（在有能力的iOS设备上）。</p>
<p>Core Image内核代码现在可以请求特定的输出像素格式。</p>
<p>Core Image引入了五个新的过滤器：</p>
<ul>
<li>CINinePartTiled</li>
<li>CINinePartStretched</li>
<li>CIHueSaturationValueGradient</li>
<li>CIEdgePreserveUpsampleFilter</li>
<li>CIClamp</li>
</ul>
<h4 id="核心运动（Core-Motion）"><a href="#核心运动（Core-Motion）" class="headerlink" title="核心运动（Core Motion）"></a>核心运动（Core Motion）</h4><h4 id="Foundation（Foundation）"><a href="#Foundation（Foundation）" class="headerlink" title="Foundation（Foundation）"></a>Foundation（Foundation）</h4><h4 id="GameKit（GameKit）"><a href="#GameKit（GameKit）" class="headerlink" title="GameKit（GameKit）"></a>GameKit（GameKit）</h4><h4 id="GameplayKit（GameplayKit）"><a href="#GameplayKit（GameplayKit）" class="headerlink" title="GameplayKit（GameplayKit）"></a>GameplayKit（GameplayKit）</h4><h4 id="HealthKit（HealthKit）"><a href="#HealthKit（HealthKit）" class="headerlink" title="HealthKit（HealthKit）"></a>HealthKit（HealthKit）</h4><h4 id="HomeKit（HomeKit）"><a href="#HomeKit（HomeKit）" class="headerlink" title="HomeKit（HomeKit）"></a>HomeKit（HomeKit）</h4><h4 id="Metal（Metal）"><a href="#Metal（Metal）" class="headerlink" title="Metal（Metal）"></a>Metal（Metal）</h4><h4 id="ModelIO（ModelIO）"><a href="#ModelIO（ModelIO）" class="headerlink" title="ModelIO（ModelIO）"></a>ModelIO（ModelIO）</h4><h4 id="Photos（Photos）"><a href="#Photos（Photos）" class="headerlink" title="Photos（Photos）"></a>Photos（Photos）</h4><h4 id="ReplayKit（ReplayKit）"><a href="#ReplayKit（ReplayKit）" class="headerlink" title="ReplayKit（ReplayKit）"></a>ReplayKit（ReplayKit）</h4><h4 id="SceneKit（SceneKit）"><a href="#SceneKit（SceneKit）" class="headerlink" title="SceneKit（SceneKit）"></a>SceneKit（SceneKit）</h4><h4 id="SpriteKit（SpriteKit）"><a href="#SpriteKit（SpriteKit）" class="headerlink" title="SpriteKit（SpriteKit）"></a>SpriteKit（SpriteKit）</h4><h4 id="UIKit（UIKit）"><a href="#UIKit（UIKit）" class="headerlink" title="UIKit（UIKit）"></a>UIKit（UIKit）</h4><h4 id="WebKit（WebKit）"><a href="#WebKit（WebKit）" class="headerlink" title="WebKit（WebKit）"></a>WebKit（WebKit）</h4><p>WebKit框架（WebKit.framework）在WKWebView对象中引入了增强的窥视和弹出支持。在iOS 10中，您可以使用webView：shouldPreviewElement：方法来确定指定的Web视图是否应显示预览。</p>
<h3 id="已弃用的API（Deprecated-APIs）"><a href="#已弃用的API（Deprecated-APIs）" class="headerlink" title="已弃用的API（Deprecated APIs）"></a>已弃用的API（Deprecated APIs）</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/第一集：看看blocks的内部是什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/第一集：看看blocks的内部是什么/" itemprop="url">第一集：看看blocks的内部是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T00:00:00+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS译文/" itemprop="url" rel="index">
                    <span itemprop="name">iOS译文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.galloway.me.uk/blog/category/ios/" target="_blank" rel="noopener">原文</a></p>
<p>今天，我从编译器的角度查看了blocks内部的工作原理。对于blocks来说，我认为是Apple添加到C语言的闭包。而且现在已经从clang/LLVM的角度将其作为C语言的一部分而正式确立。我一直就想知道什么是”block”，它为什么这么神奇的看起来像一个Objective-C对象(，你可以像对待实例一样，对它进行copy、retain、release)。这篇博客对blocks进行了一些探索。</p>
<hr>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>下面是一个block:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I'm a block!"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了一个叫<code>block</code>的变量，并且给他分配了一个很简单的块。这很简单。做完了吗？没有。我想知道编译器对这块代码究竟做了什么。</p>
<p>此外，你还可以给block传递变量：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">int</span> a) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I'm a block! a = %i"</span>, a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>甚至从blocks里面返回值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I'm a block!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而且，作为一个闭包，它包含了它所在的上下文：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"I'm a block! a = %i"</span>, a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么编译器时如何对这些代码进行分类的呢？这就是我感兴趣的。</p>
<hr>
<h3 id="进入一个简单的例子"><a href="#进入一个简单的例子" class="headerlink" title="进入一个简单的例子"></a>进入一个简单的例子</h3><p>我的第一个想法是看编译器如何编译一个非常简单的块。看下以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;dispatch/dispatch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^BlockA)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="keyword">void</span> runBlockA(BlockA block) &#123;</span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> doBlockA() &#123;</span><br><span class="line">BlockA block = ^&#123;</span><br><span class="line"><span class="comment">// Empty block</span></span><br><span class="line">&#125;;</span><br><span class="line">runBlockA(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我之所以写这两个方法是因为我既想看一个block如何被调用，也想看一个block是如何设置的。如果这两个方法都是同样的功能的话，那么这个优化器可能太聪明了，我们将看不到任何有趣的东西。我不得不使<code>runBlockA</code>函数是<code>noinline</code>的，以便优化器不仅仅是将<code>doBlockA</code>中的功能内联到同一个问题上。</p>
<p>这些相关的代码编译为（armv7, 03）：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.globl  _runBlockA</span><br><span class="line">.align  <span class="number">2</span></span><br><span class="line">.code   <span class="number">16</span>                      @ @runBlockA</span><br><span class="line">.thumb_func     _runBlockA</span><br><span class="line">_runBlockA:</span><br><span class="line">@ BB<span class="meta">#0:</span></span><br><span class="line">ldr     r1, [r0, <span class="meta">#12]</span></span><br><span class="line">bx      r1</span><br></pre></td></tr></table></figure></p>
<p>这个就是<code>runBlockA</code>函数。所以，它是相当的简单。回顾一下源代码，该函数只是调起了这个block。<code>r0</code>(register 0，寄存器0)在ARM EABI中被设置为这个函数的第一个参数。因此，第一条指令意味着r1是从被存储在r0 + 12的地址中被加载出来的。考虑到这是一个指针的引用，所以往里面读取12个字节。然后我们分支到那个地址。注意到<code>r1</code>被用了，这意味着<code>r0</code>仍然是block本身。所以，这个调用的函数很可能把这个block作为它的第一个参数。</p>
<p>由此我可以确信 block很可能是某种结构，这个block应该执行的功能被存储在这个结构的12个字节的空间里。当一个block被传递时，一个指向其中一个结构的指针就被传递了。</p>
<p>现在去看<code>doBlockA</code>方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl  _doBlockA</span><br><span class="line">.align  <span class="number">2</span></span><br><span class="line">.code   <span class="number">16</span>                      @ @doBlockA</span><br><span class="line">.thumb_func     _doBlockA</span><br><span class="line">_doBlockA:</span><br><span class="line">movw    r0, :lower16:(___block_literal_global-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">movt    r0, :upper16:(___block_literal_global-(LPC1_0+<span class="number">4</span>))</span><br><span class="line">LPC1_0:</span><br><span class="line">add     r0, pc</span><br><span class="line">b.w     _runBlockA</span><br></pre></td></tr></table></figure></p>
<p>好吧，这依然很简单。这是一个程序计数器的相对负载。您可以认为这是将名为<code>___block_literal_global</code>的变量的地址加载到<code>r0</code>中。然后<code>runBlockA</code>方法就被调用了。所以我们知道这个block对象被传到了<code>runBlockA</code>方法，这个<code>___block_literal_global</code>一定是这个block对象。</p>
<p>现在我们摸到了一点门道！但是<code>___block_literal_global</code>到底是什么？好吧，通过assembly我们发现：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.align  <span class="number">2</span>                       @ @__block_literal_global</span><br><span class="line">___block_literal_global:</span><br><span class="line">.long   __NSConcreteGlobalBlock</span><br><span class="line">.long   <span class="number">1342177280</span>              @ <span class="number">0x50000000</span></span><br><span class="line">.long   <span class="number">0</span>                       @ <span class="number">0x0</span></span><br><span class="line">.long   ___doBlockA_block_invoke_0</span><br><span class="line">.long   ___block_descriptor_tmp</span><br></pre></td></tr></table></figure></p>
<p>啊哈！这对我来说，看起来很像一个结构体。结构体中有5个值，每个值占4个字节(long型)。这个一定是<code>runBlockA</code>正在执行的block对象。继续看，结构体中的12个字节看起来很像一个函数指针，它叫做<code>___doBlockA_block_invoke_0</code>。记住，这正是<code>ruanBlock</code>函数要跳到的地方。</p>
<p>但是<code>__NSConcreteGlobalBlock</code>是什么？好，我们会回来看的。<code>___doBlockA_block_invoke_0</code>和<code>___block_descriptor_tmp</code>也是我们感兴趣的，因为它们也出现在程序集中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.align  <span class="number">2</span></span><br><span class="line">.code   <span class="number">16</span>                      @ @__doBlockA_block_invoke_0</span><br><span class="line">.thumb_func     ___doBlockA_block_invoke_0</span><br><span class="line">___doBlockA_block_invoke_0:</span><br><span class="line">bx      lr</span><br><span class="line"></span><br><span class="line">.section        __DATA,__<span class="keyword">const</span></span><br><span class="line">.align  <span class="number">2</span>                       @ @__block_descriptor_tmp</span><br><span class="line">___block_descriptor_tmp:</span><br><span class="line">.long   <span class="number">0</span>                       @ <span class="number">0x0</span></span><br><span class="line">.long   <span class="number">20</span>                      @ <span class="number">0x14</span></span><br><span class="line">.long   L_.str</span><br><span class="line">.long   L_OBJC_CLASS_NAME_</span><br><span class="line"></span><br><span class="line">.section        __TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 @ @.str</span><br><span class="line">.asciz   <span class="string">"v4@?0"</span></span><br><span class="line"></span><br><span class="line">.section        __TEXT,__objc_classname,cstring_literals</span><br><span class="line">L_OBJC_CLASS_NAME_:                     @ <span class="string">@"\01L_OBJC_CLASS_NAME_"</span></span><br><span class="line">.asciz   <span class="string">"\001"</span></span><br></pre></td></tr></table></figure></p>
<p>这个<code>___doBlockA_block_invoke_0</code>看起来非常像block本身的实现，因为我们用的这个block是个空的block。这个函数只是简单的返回了，我们究竟怎样期待一个空函数被编译。</p>
<p>然后再看<code>___block_descriptor_tmp</code>。这似乎是另一个结构体，这次他内部有4个值。第二个值是20，正好是<code>___block_literal_global</code>的大小。也许这是一个大小值呢？还有一个叫做<code>.str</code>的C字符串，它的值是<code>v4@?@</code>。这个看起来像是某种形式的编码类型。这有可能是block类型编码（即它返回空而且不需要参数）。另一个值我也不知道。</p>
<hr>
<h3 id="但是，源代码就在那儿，不是吗？"><a href="#但是，源代码就在那儿，不是吗？" class="headerlink" title="但是，源代码就在那儿，不是吗？"></a>但是，源代码就在那儿，不是吗？</h3><p>是的，源代码就在那儿，它是LLVM中<code>compiler-rt</code>项目的一部分。通过代码我在<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">Block_private.h</a>中找到如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line"><span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line"><span class="keyword">void</span> *isa;</span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"><span class="keyword">int</span> reserved;</span><br><span class="line"><span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line"><span class="keyword">struct</span> Block_descriptor *descriptor;</span><br><span class="line"><span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个看起来很熟悉！这个<code>Block_layout</code>正是我们的<code>___block_literal_global</code>，而这个<code>Block_descriptor</code>正是我们的<code>___block_descriptor_tmp</code>。继续看，关于descriptor中的第二个值的大小我的猜想是对的。有点奇怪的是<code>Block_descriptor</code>中的第三个和第四个值。这些看起来应该是函数指针，但是在我们的编译情况下，他们似乎是2个字符串。现在我会忽略这个小点。</p>
<p><code>Block_layout</code>的<code>isa</code>是有趣的，因为它必须是_NSConcreteGlobalBlock是什么，也必须是块如何模拟为Objective-C对象。如果<code>_NSConcreteGlobalBlock</code>是一个<code>Class</code>，那么Objective-C消息分派系统将会很乐意将块对象视为普通对象。这与如何免费桥接的工作类似。有关这方面的更多信息，请阅读Mike Ash关于它的优秀<a href="http://www.mikeash.com/pyblog/friday-qa-2010-01-22-toll-free-bridging-internals.html" target="_blank" rel="noopener">博客文章</a>。</p>
<p>将所有这些都拼接在一起，编译器看起来像将代码视为这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;dispatch/dispatch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="keyword">void</span> runBlockA(<span class="keyword">struct</span> Block_layout *block) &#123;</span><br><span class="line">block-&gt;invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> block_invoke(<span class="keyword">struct</span> Block_layout *block) &#123;</span><br><span class="line"><span class="comment">// Empty block function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> doBlockA() &#123;</span><br><span class="line"><span class="keyword">struct</span> Block_descriptor descriptor;</span><br><span class="line">descriptor-&gt;reserved = <span class="number">0</span>;</span><br><span class="line">descriptor-&gt;size = <span class="number">20</span>;</span><br><span class="line">descriptor-&gt;<span class="keyword">copy</span> = <span class="literal">NULL</span>;</span><br><span class="line">descriptor-&gt;dispose = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout block;</span><br><span class="line">block-&gt;isa = _NSConcreteGlobalBlock;</span><br><span class="line">block-&gt;flags = <span class="number">1342177280</span>;</span><br><span class="line">block-&gt;reserved = <span class="number">0</span>;</span><br><span class="line">block-&gt;invoke = block_invoke;</span><br><span class="line">block-&gt;descriptor = descriptor;</span><br><span class="line"></span><br><span class="line">runBlockA(&amp;block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这很好知道。 现在在block的引擎盖下发生了什么事情变得更加有意义。</p>
<hr>
<h3 id="下一集讲什么？"><a href="#下一集讲什么？" class="headerlink" title="下一集讲什么？"></a>下一集讲什么？</h3><p>接下来我将看一个block，它接收一个参数和一个从封闭范围捕获变量的block。这些肯定会使事情有所不同！所以，watch this space for more.</p>
<p>由Matt Galloway 在2012年8月11日发表 -  <a href="http://www.galloway.me.uk/blog/category/programming/" target="_blank" rel="noopener">rogramming</a>, <a href="http://www.galloway.me.uk/blog/category/ios/" target="_blank" rel="noopener">iOS</a></p>
<p>还有一篇简书上写的貌似很好的<a href="http://www.jianshu.com/p/51d04b7639f1" target="_blank" rel="noopener">一篇文章</a>，还没来得及看</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/第十篇、小代码测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/第十篇、小代码测试/" itemprop="url">第十篇、小代码测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T00:00:00+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(1)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"123"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@"123"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:str1];</span><br><span class="line"><span class="built_in">NSString</span> *str4 = [str1 stringByAppendingString:<span class="string">@""</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p, %p"</span>, str1, str1.UTF8String);    <span class="comment">// 0x100048220, 0x10004740a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p, %p"</span>, str2, str2.UTF8String);    <span class="comment">// 0x100048220, 0x10004740a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p, %p"</span>, str3, str3.UTF8String);    <span class="comment">// 0x100048220, 0x10004740a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p, %p"</span>, str4, str4.UTF8String);    <span class="comment">// 0x100048220, 0x10004740a</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述代码表明：编译器在整理代码中的字符串的时候，发现两个字符串相同，于是在字符串表里只保存了一个字符串，并将两处的代码的引用指向这个表的同一个字符串中</p>
</blockquote>
<p>(2)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="built_in">NSString</span> *a = <span class="string">@"12345"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, a); <span class="comment">// 0x1000482a0</span></span><br><span class="line">a = <span class="string">@"234234"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, a); <span class="comment">// 0x1000482e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="built_in">NSString</span> *a = <span class="string">@"12345"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, a); <span class="comment">// 0x1000482a0</span></span><br><span class="line">a = <span class="string">@"12345"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, a); <span class="comment">// 0x1000f42a0</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/第十一篇、Objective-C中的消息与消息转发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/第十一篇、Objective-C中的消息与消息转发/" itemprop="url">第十一篇、Objective-C中的消息与消息转发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T00:00:00+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、消息发送"><a href="#一、消息发送" class="headerlink" title="一、消息发送"></a>一、消息发送</h3><p>OC中的对象调用方法，也就是发消息。这个消息机制室友运行时实现，非常灵活动态。<br>[obj method]最终都会被转换为objc_msgSend(obj, @selector(method))；</p>
<blockquote>
<p>其原型是： id objc_msgSend(id self, SEL _cmd, …)<br>self是消息接受者，_cmd是选择器，…是可变参数列表</p>
</blockquote>
<p>当向一般对象发送消息时，调用objc_msgSend；当向super发送消息时，调用的是objc_msgSendSuper； 如果返回值是一个结构体，则会调用objc_msgSend_stret或objc_msgSendSuper_stret。</p>
<p>下面一段代码是objc_msgSend()函数内部所做的事情：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend ( <span class="keyword">id</span> <span class="keyword">self</span> , SEL op , . . . ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">self</span> ) <span class="keyword">return</span> <span class="literal">nil</span> ;</span><br><span class="line">IMP imp = class_getMethodImplementation ( <span class="keyword">self</span> -&gt; isa , SEL op ) ;</span><br><span class="line">imp ( <span class="keyword">self</span> , op , . . . ) ; <span class="comment">//调用这个函数，伪代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找IMP</span></span><br><span class="line">IMP class_getMethodImplementation ( Class cls , SEL sel ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ! cls || ! sel ) <span class="keyword">return</span> <span class="literal">nil</span> ;</span><br><span class="line">IMP imp = lookUpImpOrNil ( cls , sel ) ;</span><br><span class="line"><span class="keyword">if</span> ( ! imp ) <span class="keyword">return</span> _objc_msgForward ; <span class="comment">//这个是用于消息转发的</span></span><br><span class="line"><span class="keyword">return</span> imp ;</span><br><span class="line">&#125;</span><br><span class="line">IMP lookUpImpOrNil ( Class cls , SEL sel ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ! cls -&gt; initialize ( ) ) &#123;</span><br><span class="line">_class_initialize ( cls ) ;</span><br><span class="line">&#125;</span><br><span class="line">Class curClass = cls ;</span><br><span class="line">IMP imp = <span class="literal">nil</span> ;</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">//先查缓存,缓存没有时重建,仍旧没有则向父类查询</span></span><br><span class="line"><span class="keyword">if</span> ( ! curClass ) <span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">if</span> ( ! curClass -&gt; cache ) fill_cache ( cls , curClass ) ;</span><br><span class="line">imp = cache_getImp ( curClass , sel ) ;</span><br><span class="line"><span class="keyword">if</span> ( imp ) <span class="keyword">break</span> ;</span><br><span class="line">&#125; <span class="keyword">while</span> ( curClass = curClass -&gt; superclass ) ;</span><br><span class="line"><span class="keyword">return</span> imp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>总的来说经历了一下几个步骤：</p>
<ul>
<li>1、先通过 IMP cache_getImp(cls, sel) 函数在Class的方法缓存中查找IMP，如果缓存不存在的话会初始化缓存。</li>
<li>2、没有找到的话，会在cls的父类的Class里查找。</li>
<li>3、还是没有找到，则会通过 IMP _objc_msgForward 消息转发来找到这个IMP。最后调用imp(self, op, …)方法。</li>
</ul>
</blockquote>
<h3 id="二、消息转发："><a href="#二、消息转发：" class="headerlink" title="二、消息转发："></a>二、消息转发：</h3><p>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
<p>先尝试向一个对象发送一条不存在的消息：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test *test = [ Test new ] ;</span><br><span class="line">[ test performSelector ( <span class="keyword">@selector</span> ( xxx ) ) ] ;</span><br></pre></td></tr></table></figure></p>
<p>通过特定的调试方式可以拿到消息转发做了以下事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ Test NSObject initialize</span><br><span class="line">+ Test NSObject new</span><br><span class="line">+ Test NSObject alloc</span><br><span class="line">+ Test NSObject allocWithZone :</span><br><span class="line">- Test NSObject init</span><br><span class="line">- Test NSObject performSelector :</span><br><span class="line">+ Test NSObject resolveInstanceMethod :</span><br><span class="line">- Test NSObject forwardingTargetForSelector :</span><br><span class="line">- Test NSObject methodSignatureForSelector :</span><br><span class="line">- Test NSObject class</span><br><span class="line">- Test NSObject doesNotRecognizeSelector :</span><br></pre></td></tr></table></figure></p>
<p>结合NSObject文档可以知道，_objc_msgForward消息转发做了如下几件事： </p>
<blockquote>
<p>1.调用resolveInstanceMethod:方法，允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回。如果仍没实现，继续下面的动作。</p>
</blockquote>
<blockquote>
<p>2.调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接转发给它。如果返回了nil，继续下面的动作。</p>
</blockquote>
<blockquote>
<p>3.调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。</p>
</blockquote>
<blockquote>
<p>4.调用forwardInvocation:方法，将地3步获取到的方法签名包装成Invocation传入，如何处理就在这里面了。</p>
</blockquote>
<blockquote>
<p>上面这4个方法均是模板方法，开发者可以override，由runtime来调用。最常见的实现消息转发，就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</p>
</blockquote>
<p>这里可以看到<a href="http://www.tuicool.com/articles/iEbmUr" target="_blank" rel="noopener">原文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/10/第八篇、小问题小总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/10/第八篇、小问题小总结/" itemprop="url">第八篇、小问题小总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-10T00:00:00+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、IBOutlet连出来的视图属性为什么可以被设置成weak?<br>答：IBOutlet是连接在ViewController控制器中的，当IBOutlet对象是ViewController的直接拥有者时(如self.view，控制器必须持有它)，属性必须设置为strong。而一般我们的控件是添加在self.view中的，self.view直接持有这些控件，所以控件在控制器中的IBOutlet可以设置为weak，即不持有，这样的另一个好处是，当控制器dealloc时，我们不需要手动把这些控件的指针置为nil，因为他们weak属性的，会自动置为nil，这会给我们省了很多事情。而且我们向nil发送消息的时候不会崩溃</p>
<hr>
<p>2、什么是野指针？与空指针有什么不同<br>答：假设指针p指向对象a的地址，然后对象a被释放了，但是p还是指向着a释放前的地址，那么a就是野指针。野指针指向着一块不可用的内存区域，如果对野指针进行操作的话，会使程序发生不可预知的错误。一般造成野指针的原因有两个：一个是指针在初始化的时候未赋值，此时的指针会乱指一气。另一个就是指针所指向的对象释放后，未把指针置空。</p>
<p>空指针就是指向内存地址首位，也就是指针值为NULL的指针。</p>
<hr>
<p>3、<code>strong</code>关键字在声明属性时表明了一种拥有关系，当为这种属性设置新值时，设置方法会先释放旧值，即解除之前对旧值得持有关系(引用计数减一)，然后持有新值(新值得引用计数加一)，最后保存指针的值。<br><code>weak</code>关键字在声明属性时与<code>strong</code>相反，为这总属性赋值时，是不会持有任何对象的，所以自然不存在释放旧值和持有新值一说，只是单纯的保存指针值而已。而且最关键的是，这个属性所指向的对象在释放后，属性指针会自动清空成为空指针。<br><code>assign</code>关键字在修饰属性时跟<code>weak</code>会有一点类似，只是单纯地保存指针的值而已。一般用这个来声明简单数据类型，如果用这个属性保存对象时，对象释放后，属性会成为野指针。<br><code>copy</code>关键字在声明属性时，当为属性赋值时，也会先解除对旧值(对象)的持有关系，然后把新值(对象)拷贝一份，并持有这个拷贝后的值，而且保存拷贝后的值得指针。</p>
<blockquote>
<p>综上：<code>strong</code>和<code>copy</code>声明的属性不仅会保存新值，而且还会持有新值，在赋新值时会解除对之前旧值的持有关系。但是<code>weak</code>和<code>assign</code>仅仅只会保存新值，并不会持有它。</p>
</blockquote>
<hr>
<p>4、block为什么要使用copy，为什么会引起循环引用，怎么解决?<br>答：block一开始在创建的时候，是放在栈区的，是可能随时会被释放的，如果不用copy给它赋值的话，那么，block在回调的时候可能已经找不到了，程序会崩溃：Thread1:EXC_BAD_ACCESS，也就是说block已经被销毁了。<br>所以声明block属性时，得用copy，那么在给block赋值的时候，会把block拷贝到堆区，这样block就不会被编译器自动释放了。<br><code>注</code>：ARC下，block有三种，一种是全部block，一种是栈区block(即：内存地址在栈区)，一种是堆区block(即：内存地址在堆区)。<br>看代码：一个很常见的viewcontroller跳转到viewcontroller2，在2中声明了一个block。<br>viewcontroller.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">IBAction</span>)present:(<span class="built_in">UIButton</span> *)sender &#123;    </span><br><span class="line">ViewController2 *vc = [ViewController2 new];</span><br><span class="line">vc.callback = ^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"^^^^^^^^^%@, str);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">[self presentViewController:vc animated:YES completion:nil];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NSLog(@"</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;block : %<span class="string">@", vc.callback);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>viewcontroller2.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController2</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">void</span> (^callback) (<span class="built_in">NSString</span> *str);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>viewcontroller2.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController2</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController2</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="built_in">UIStoryboard</span> *sb = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span> = [sb instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> purpleColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)back:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line"><span class="keyword">self</span>.callback(<span class="string">@"你好"</span>);</span><br><span class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;block : &lt;__NSGlobalBlock__: <span class="number">0x1018530c0</span>&gt;</span><br><span class="line">&gt;^^^^^^^^^^你好</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>block内部并没有访问到外部变量，所以这个block是<code>__NSGlobalBlock__</code>全局block，大家注意到viewcontroller.h中我声明block是用的assign，这是无关紧要的。</p>
</blockquote>
<p>然后改一下代码：<br>看代码：一个很常见的viewcontroller跳转到viewcontroller2，在2中声明了一个block。<br>viewcontroller.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)present:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line"><span class="keyword">self</span>.name = <span class="string">@"123456"</span>;</span><br><span class="line"></span><br><span class="line">ViewController2 *vc = [ViewController2 new];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">vc.callback = ^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"^^^^^^^^^%@, name:%@"</span>, str, weakSelf.name);</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;block : %@"</span>, vc.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;block : &lt;__NSStackBlock__: <span class="number">0x7fff5c233620</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/source/summary8_p_1.png" alt=""></p>
<blockquote>
<p>然后就崩溃了，说block已经被释放了，因为现在的block是<code>__NSStackBlock__</code>栈区block，因为它内部访问了self.name。此时声明block应该声明为copy。<br>viewcontroller2.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController2</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^callback) (<span class="built_in">NSString</span> *str);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>输出<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;block : &lt;__NSMallocBlock__: <span class="number">0x608000044da0</span>&gt;</span><br><span class="line">^^^^^^^^^你好, name:<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>大家看到此时的block是堆区的block，<code>__NSMallocBlock__</code>，很显然block从栈区被copy到了堆区。</p>
</blockquote>
<p>引起循环引用的原因是：self-&gt;vc-&gt;vc.callback-&gt;self，即self持有vc，vc<br>持有block，block内部又持有self，所以用__weak来声明一个weakSelf，当在block里访问weakSelf时，block就不会持有self，就避免了循环引用。</p>
<p>为什么修改block外部的变量，需要用__block？</p>
<blockquote>
<p>我们都知道：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。<br>引用：<a href="http://www.jianshu.com/p/a1c8532e172d" target="_blank" rel="noopener">在block内如何修改block外部变量引发的思考
</a></p>
</blockquote>
<blockquote>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？</p>
</blockquote>
<hr>
<p>5、@property的本质是什么？<br>答：想要了解这个问题的话，就得动脑筋想一下。首先它一定对应着一个实例变量ivar，这是毋庸置疑的，因为这是对应着一个类所具有的属性。就如同汽车类一定具有方向盘、轮子这些属性一样，类也必须有变量来保存它所具有的属性。<br>如果只是想达到这个目的，那么只用实例变量ivar不就可以了吗？但是明显，这种实例变量不具备设置实例变量的值和获取实例变量的值这些两个方法。所以，苹果就引入了@property，它不仅仅是一个实例变量，而且自动具有对应的setter和getter方法。<br>所以 @property = ivar + setter + getter<br>而且，property中还可以设置内存管理语义：strong、weak、copy、assign等</p>
<blockquote>
<p>property要想保存这么多的设置项，其实可以猜到，property其实是个结构体指针，指向着一个结构体。property在runtime中是objc_property_t，定义如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而objc_property是一个结构体，包括name和attributes，定义如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t objc_property;</span><br><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下：</span><br><span class="line"><span class="comment">/// Defines a property attribute</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">/**&lt; The name of the attribute */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;     </span><br><span class="line"><span class="comment">/**&lt; The value of the attribute (usually empty) */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *value;    </span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。</p>
</blockquote>
<blockquote>
<p>例如：我们定义一个string的property@property (nonatomic, copy) NSString *string;，通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为T@”NSString”,C,N,V_string</p>
</blockquote>
<blockquote>
<p>其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。</p>
</blockquote>
<hr>
<p>6、weak的实现原理及 runtime 如何实现 weak 变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。<br>一些参考文章，还没来得及看<br><a href="http://www.jianshu.com/p/ed65d71554d8" target="_blank" rel="noopener">如何使用 Runtime 给现有的类添加 weak 属性</a><br><a href="https://github.com/Magic-Unique/Runtime" target="_blank" rel="noopener">Runtime基础技能</a><br>答：</p>
</blockquote>
<hr>
<p>7、一个小问题<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"key"</span> : <span class="string">@"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *key1 = <span class="string">@"key"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *key2 = [<span class="string">@"ke"</span> stringByAppendingString:<span class="string">@"y"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *value1 = dict[key1];</span><br><span class="line"><span class="built_in">NSString</span> *value2 = dict[key2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出来的的这两个值会有不同吗？为什么？</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>8、</p>
<blockquote>
<p>_objc_msgForward是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
<p>objc_msgSend在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。</p>
</blockquote>
<hr>
<p>9、在多线程中使用block时要注意什么？<br>答：一般，我们在使用block时，为了避免发生循环引用，在block中使用self时，要把它转换为weakSelf弱引用。但是如果在多线程中使用weakSelf时，self可能在其他的线程中被释放了，此时weakSelf就为空了，程序执行到这个block时，就会造成不可预知的问题。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person new];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(p)weakP = p;</span><br><span class="line">p.name = <span class="string">@"张三"</span>;</span><br><span class="line">p.myBlock = ^ &#123;</span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakP)strongP = weakP;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"****: %@"</span>, strongP.name);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.myBlock();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述代码如果不加strongP的话，代码待因处理为null，因为weakP是弱引用的，5秒过后就已经被释放了。</p>
</blockquote>
<hr>
<p>10、Autorelease对象什么时候释放？<br>答：这个问题拿来做面试题，问过很多人，没有几个能答对的。很多答案都是“当前作用域大括号结束时释放”，显然木有正确理解Autorelease机制。<br>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<p>11、autorelease对象<br>按照苹果的编程约定，由非alloc,copy返回的对象都是autorelease的，所以对于以下代码，虽然变量number是__weak的，但是由于[NSNumber numberWithInt:100]返回的对象是autorelase的，所以仍然能通过NSLog打印出来。</p>
<p>__weak NSNumber *number = [NSNumber numberWithInt:100];<br>NSLog(@”number = %@”, number);</p>
<p>从汇编代码中看，以上代码在创建number变量时，是通过objc_loadWeak方法进行的。而根据 Clang的官方文档，objc_loadWeak方法会retain并autorelease这个对象。所以给一个weak对象赋值，它并不会马上释放，而是会放到autorelease pool中，与autorelease pool一起释放。</p>
<p>如下是objc_loadWeak的代码示例：</p>
<p>id objc_loadWeak(id *object) {<br>return objc_autorelease(objc_loadWeakRetained(object));<br>}<br>为了验证这个回答，我们又做了一个有趣的例子来验证，如下所示：</p>
<p>__weak NSNumber *number;<br>@autoreleasepool {<br>number = [NSNumber numberWithInt:100];<br>}<br>NSLog(@”number = %@”, number);<br>在上面这个例子中，果然如我们所料，number在通过NSLog查看值时，变成了nil。</p>
<hr>
<p>12、下面的代码会造成什么问题？<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.bounds.size.width * <span class="number">0.5</span>, <span class="keyword">self</span>.bounds.size.height * <span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:frame];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般不会有什么问题，但是在这样用的时候会出问题：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestViewController *vc = [[TestViewController alloc] init];</span><br><span class="line">vc.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<p>主要是考 viewcontroller的生命周期<br>在外部给vc.view赋值frame时，这时候view还没被创建。此时会这样执行：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)view &#123;</span><br><span class="line"><span class="keyword">if</span> (!_view) &#123;</span><br><span class="line">[<span class="keyword">self</span> loadView];</span><br><span class="line">[<span class="keyword">self</span> viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是设置vc.view.frame = CGRectMake(0, 0, 100, 100);的代码会在viewDidLoad之后调用。</p>
<hr>
<p>13、iOS事件传递<br>（1）发生触摸事件后，系统会把点击事件加入一个队列（先进先出，后进后出）。当前的UIApplication(单例)从队列中取出事件然后在视图层次结构找到合适的视图来处理触摸事件。<br>（2）触摸事件的传递是从父控件传递到子控件的，即UIApplication -&gt; window -&gt; view。如果父控件不能响应用户交互，那么子控件就不可能接收到事件。<br>这也就是为什么在UIImageView上面添加一个Button后，Button不能响应事件。<br>（3）影响用户交互的几种可能：</p>
<ul>
<li>userInterfaceEnable = NO;</li>
<li>hidden = NO;</li>
<li>alpha = 0.0;</li>
</ul>
<p>（4）经常会碰到的手势冲突问题<br>如下图：视图的层级是最下面是：window -&gt; view -&gt; maskView -&gt; tableView<br>maskView和tableView构成整个弹出视图。<br>在maskView上添加了一个点击手势，当点击背景maskView时，弹出视图消失。<br>可是，现在会遇到这样一个问题：当点击在tableView上时，不会响应tableView的点击手势，而还是会响应点击手势。<br>结合上面的触摸事件的传递大概就会知道原因：点击在tableView上点击时，事件会先传到UIApplication，然后再到window，… 先到maskView，系统会发现maskView很符合点击手势，所以就不会再往上遍历了，tableView的点击就不会响应了<br><img src="/source/summary8_p_2.png" alt=""></p>
<p>解决办法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消除手势冲突：手势只作为点击非tableView区域可以收起menu的作用，如果不屏蔽，则点击cell时不会响应didSelectRowAtIndexPath方法，只会响应点击手势</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UITableViewCellContentView"</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>14、代理和通知的区别<br>代理只能一对一<br>通知可以一对多</p>
<p>代理是委托设计模式，用于两个对象之间的交互。可用于一个对象向外传递信息，也可用于从外部回传信息(如：tableView的代理，tableView内部的样式已经排版好了，只是需要数据而已)。  从外部回传信息是通知所不具备的。</p>
<p>通知是观察者模式。</p>
<p>kvo<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cc监听了aa的name属性的改变</span></span><br><span class="line">[aa addObserver:cc forKeyPath:<span class="string">@"name"</span> options: <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// cc得实现监听方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当监听到object的keyPath属性发生了改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"监听到%@对象的%@属性发生了改变， %@"</span>, object, keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>15、如何解决NSTimer在当前页面UIScrollView滑动时，timer会停止的问题。<br>答：NSTimer的运行实际上timer被加入到一个RunLoop中而已。默认的用schduled开头的类方法创建的timer都是已经被加到RunLoop中的，所以timer创建之后，timer就已经开启了。一个RunLoop在同一时间段只能处在一种RunLoopModel下。当更换了mode时，之前的mode就会被停止。<br><strong>NSRunLoopMode</strong>：</p>
<blockquote>
<ul>
<li>NSDefaultRunLoopMode：默认状态，空闲状态</li>
<li>NSTrackingRunLoopMode：滑动滚动视图</li>
<li>UIInitializationRunLoopMode；私有，App启动时</li>
<li>NSRunLoopCommonMode：默认包括上面的第一和第二</li>
</ul>
</blockquote>
<p>NSTimer的mode是上面的额第一种，而UIScrollView的mode是第二种，无法同事存在。所以滑动scrollView时，timer是停止的。<br>解决办法：把timer加到NSRunLoopCommonMode的RunLoop中：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;   </span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.5</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"时间打印：%d"</span>, i);</span><br><span class="line">i ++;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure></p>
<hr>
<p>16、Struct 和Class的区别<br>答：Class的本质是一个结构体指针，所以它是一个引用类型。而结构体只是一个复杂的数据类型，是值类型。<br>Class是面向对象编程的，可以继承。<br>Struct是面向过程编程的。</p>
<p>17、介绍一下观察者模式<br>答：观察者模式提供一种在程序中进行广播的机制，而它的本质其实就是一个通知分发表。这个分发表负责维护各个通知注册的观察者，在对应的通知到达时，去查找相应的观察者，讲通知转发给它们进行处理。</p>
<p><code>NotificationCenter</code>在多线程中需要注意什么问题？<br>答：官方文档解释：In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.<br>翻译：在多线程应用中，通知的传递和通知的发送是在同一个线程中，但是可能会跟通知的注册不在一个线程中。<br>这里涉及到三个线程：注册通知的线程、发送通知的线程、转发通知的线程。其中后两个一定是在同一个线程中。<br>看代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"注册通知的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handelNtf) name:kTESTNTF object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"发出通知的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kTESTNTF object:<span class="literal">nil</span>];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) handelNtf &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行通知事件的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册通知的线程：&lt;NSThread: 0x170262880&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">发出通知的线程：&lt;NSThread: 0x174265400&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">执行通知事件的线程：&lt;NSThread: 0x174265400&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>虽然我们在主线程中注册了通知及其触发后执行的事件：handelNtf，但是由于通知是在另一个线程中post的，所以，最终导致handelNtf事件的处理也在另一个线程中了。</p>
</blockquote>
<blockquote>
<p>所以以后在注册通知更新UI时，一定要保证更新的方法在主线程中，即：加上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) upDateUI &#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">NSLog(@&quot;执行通知事件的线程：%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><a href="http://www.cocoachina.com/ios/20150316/11335.html" target="_blank" rel="noopener">Notification与多线程</a></p>
<p>附带问题：NSNotificationCenter为什么要手动移除？(iOS9以后不需要手动移除了)<br>答：因为观察者注册通知时，通知中心会对观察者进行unsafe_unretained引用，通知中心不会持有观察者。当观察者销毁时，如果不移除通知，那么这个通知依然存在，”观察者”还能接收到通知，但是实际上“观察者”已经销毁，此时，通知的接受者其实已经是个野指针了，会引起崩溃。iOS9以后，我们不需要手动移除通知了，因为iOS9以后通知中心对观察者的引用是用的weak弱引用。</p>
<hr>
<p>18、HTTPS = HTTP + SSL/TLS。在HTTP上又加了一层处理加密信息的模块。<br>客户端用HTTPS协议访问客户端时，客户端和服务端是怎么进行通讯的？<br><img src="/source/summary8_p_3.png" alt=""></p>
<blockquote>
<ul>
<li>客户端发起一个HTTPS请求</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>服务端的配置<br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>传送证书<br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>客户端解析证书<br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>传送加密信息<br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>服务端解密信息<br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>传输加密后的信息<br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>客户端解密信息<br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</li>
</ul>
</blockquote>
<hr>
<p>19、RunLoop<br><a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">猛戳</a></p>
<hr>
<p>20、你在项目中遇到过哪些坑，你是如何解决的？<br>答：</p>
<hr>
<p>21、如何正常的销毁一个NSTimer？<br>答：当在控制器中创建NSTimer时指定其repeats属性为YES，则timer计时器就会强引用(持有)self，如果timer不invalidate的话，其dealloc方法就不会被调用。换句话说，我们不能在dealloc中去调用[timer invalidate]方法，这样会造成dealloc方法永远无法执行。<br>应该这样写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">_timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handelTimer) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handelTimer &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"我在打印"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidDisappear:animated];</span><br><span class="line"></span><br><span class="line">[_timer invalidate];</span><br><span class="line">_timer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line"><span class="comment">// 不能再这里面执行timer销毁的方法。</span></span><br><span class="line"><span class="comment">//    [_timer invalidate];</span></span><br><span class="line"><span class="comment">//  _timer = nil;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"----------dealloc--------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>22、有哪些常用的iOS系统原生的框架？<br>答：<br>| 框架名称      |    功能 |<br>| :——– | :——–|<br>| AddressBook.framework  | 提供访问存储核心数据库中用户联系人信息的功能|<br>| AddressBookUI.framework     |   提供一个用户界面，用于显示存储在地址簿中的联系人信息 |<br>| AudioToolbox.framework      |   提供音频录制和回放的底层API，同时也负责管理音频硬件 |<br>| AudioUnit.framework |   提供一个接口，让我们的应用程序可以对音频进行处理|<br>| AVFoundation.framework |  提供音频录制和回放的底层API，同时也负责管理音频硬件|<br>| CFNetwork.framework |  访问和配置网络，像HTTP、FTP和Bonjour Services|<br>| CoreFoundation.framework |  提供抽象的常用数据类型，如 Unicode strings、XML、URL等 |<br>| CoreGraphics.framework | 提供2D绘制的基于C的API |</p>
<p><a href="http://blog.csdn.net/yuhuangc/article/details/7575519" target="_blank" rel="noopener">iOS的主要框架介绍</a></p>
<p><a href="http://www.cnblogs.com/ygm900/p/3599081.html" target="_blank" rel="noopener">IOS 整体框架类图值得收藏</a></p>
<hr>
<p>23、关于performSelector调用和直接调用区别？<br>答：<br>下面两段代码都在主线程中运行，我们在看别人代码时会发现有时会直接调用，有时会利用performSelector调用，今天看到有人在问这个问题，我便做一下总结<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[delegate imageDownloader:self didFinishWithImage:image];</span><br><span class="line">[delegate performSelector:@selector(imageDownloader:didFinishWithImage:)withObject:self withObject:image];</span><br></pre></td></tr></table></figure></p>
<p>（1）erformSelector<code>是运行时系统负责去找方法的，在编译时候不做任何校验；如果直接调用编译是会自动校验。如果</code>imageDownloader:didFinishWithImage:imag: <code>不存在，那么直接调用 在编译时候就能够发现（借助Xcode可以写完就发现），但是使用performSelector的话一定是在运行时候才能发现（此时程序崩溃）；Cocoa支持在运行时向某个类添加方法，即方法编译时不存在，但是运行时候存在，这时候必然需要使用performSelector去调用。所以有时候如果使用了performSelector，为了程序的健壮性，会使用检查方法</code>- (BOOL)respondsToSelector:(SEL)aSelector`;<br>（2）、直接调用方法时候，一定要在头文件中声明该方法的使用，也要将头文件import进来。而使用performSelector时候， 可以不用import头文件包含方法的对象，直接用performSelector调用即可。</p>
<hr>
<p>24、简单模拟FMDB在多线程是的执行顺序。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.default"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"我要睡眠5s了！"</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-05-22 18:11:55.354354 timer[12001:5652713] 1</span><br><span class="line">2017-05-22 18:11:55.354553 timer[12001:5652713] 5</span><br><span class="line">2017-05-22 18:11:55.354607 timer[12001:5652744] 2</span><br><span class="line">2017-05-22 18:11:55.354759 timer[12001:5652744] 我要睡眠5s了！</span><br><span class="line">2017-05-22 18:12:00.360118 timer[12001:5652744] 3</span><br><span class="line">2017-05-22 18:12:00.360426 timer[12001:5652746] 4</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看出，你用FMDBDataBaseQueue提交SQL请求时，请求是在同步队列中按顺序同步执行的。所以不会出现资源抢夺问题。</p>
</blockquote>
<hr>
<p>25、NSOperation和GCD</p>
<blockquote>
<p><code>NSOperation</code>和<code>NSOperationQueue</code>是提供的面向对象的多线程接口，在项目中使用的时候会使项目结构更好，建议在复杂的项目中使用。而且它可以很好地管理线程总数以及线程中各个操作的依赖关系，可以控制操作的执行顺序。  </p>
</blockquote>
<blockquote>
<p><code>GCD</code>(Grand Central Dispatch)，是iOS SDK提供的一个系统级别的多线程api，能充分利用多核硬件。它与<code>NSOperation</code>最大的区别是它是用C语言开发的，是面向过程的。它的抽象度很高，所以使用起来也最方便。可以在简单的多线程项目中使用。</p>
</blockquote>
<hr>
<p>26、<code>viewDidUnLoad</code>，在iOS6以前，当系统受到Memory Warning时，当前未在界面上显示的ViewController的view会被Unload掉，viewDidUnLoad就会被自动调用。view的子视图也会被置为nil，此时因为那些子视图在Controller中是弱引用的(参考IBOutlet连接的属性)，所以子视图就会被成功释放。<br>iOS6以后，<code>viewDidUnLoad</code>被废弃了。当系统受到Memory Warning时，是不会把view Unload掉的。</p>
<ol>
<li>UIView 有一个 CALayer 的成员变量，CALayer 是具体用于将自己画到屏幕上的。</li>
<li>CALayer 是一个 bitmap 图象的容器类，当 UIView 调用自身的 drawRect 时，CALayer 才会创建这个 bitmap 图象类。</li>
<li>具体占内存的其实是一个 bitmap 图象类，CALayer 只占 48bytes, UIView 只占 96bytes。而一个 iPad 的全屏 UIView 的 bitmap 类会占到 12M 的大小！</li>
<li>在 iOS6 时，当系统发出 MemoryWarning 时，系统会自动回收 bitmap 类。但是不回收 UIView 和 CALayer 类。这样即回收了大部分内存，又能在需要 bitmap 类时，通过调用 UIView 的 drawRect: 方法重建。</li>
</ol>
<blockquote>
<p>也就是说view的生命周期是跟ViewController是一样的了，所以我们在声明view的子视图时，也没有必要把子视图设置为<code>weak</code>了，因为view是强引用属性的，而view的生命周期跟ViewController是一样的，所以不存在iOS6以前那种收到<code>MemoryWarning</code>时view被销毁，子视图被销毁，但是ViewController依然存在的情况。要么一同存在，要么都被销毁。</p>
</blockquote>
<p>下图实线表示强引用，虚线表示弱引用。<br><img src="/source/summary8_p_4.png" alt=""><br>具体可以看唐巧的这一片文章：<a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">理解 iOS 的内存管理</a></p>
<hr>
<p>27、理解OC的动态语言特性，了解runtime，请看下面两篇文章：<br>(1)王巍：<a href="https://onevcat.com/2012/04/objective-c-runtime/" target="_blank" rel="noopener">深入Objective-C的动态特性</a><br>(2) <a href="http://www.jianshu.com/p/bbeada1e75af" target="_blank" rel="noopener">oc语言的特性 动态类型识别，动态绑定，动态加载</a></p>
<hr>
<p>28、对anchorPoint的理解。<br><img src="/source/summary8_p_5.jpg" alt=""><br>中心点position跟锚点anchorPoint是有关系的。一般来说anchorPoint是(0.5, 0.5)。你可以想象当把这个图层进行旋转的时候是根据中心点position来的。当改变anchorPoint为(0, 0)的时候，其实position的坐标是没有改变的，但是旋转中心点坐标是必须要改变的。</p>
<blockquote>
<p>你可以理解为：改变anchorPoint就是改变的layer的旋转中心点坐标(这个旋转中心点坐标是针对自身坐标系的)，但是却不会改变图层的中心点的坐标(图层中心点坐标是针对父图层坐标系的)。而这两个中心点又必须是同一点。这样的话，只有把图片向右下角移动才能满足以上条件。<br>anchorPoint只是决定以“身体”的哪一个点来作为旋转中心点。<br>一个时钟的项目会用到anchorPoint。</p>
</blockquote>
<p>29、一个视图或者layer的frame与它的bounds、center(position)和transform有关。因为frame始终代表的是一个水平放置的矩形区域，所以当视图发生旋转时，frame时会改变的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/第七篇、《OC高级编程》读后笔记，未完待续…/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/第七篇、《OC高级编程》读后笔记，未完待续…/" itemprop="url">第七篇、《OC高级编程》读后笔记，未完待续…</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T00:00:00+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一章、自动引用计数"><a href="#第一章、自动引用计数" class="headerlink" title="第一章、自动引用计数"></a>第一章、自动引用计数</h3><p>（1）ARC：Automatic Reference Counting<br>使用条件：</p>
<ul>
<li>使用Xcode 4.2或以上版本</li>
<li>使用LLVM编译器3.0或以上版本</li>
<li>编译器选项中设置ARC为有效</li>
</ul>
<hr>
<p>（2）使用alloc、new、copy、mutableCopy方法时，会生成并持有对象。</p>
<hr>
<p>（3）retain / release：持有 / 释放。<br>存在理由：<br>想持有非自己生成的对象时，需要用retain<br>释放自己持有的对象时，需要用release<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种使用便利构造器创建的对象，属于非自己生成并持有的对象，只能说自己是取得了该对象而已，但非自己持有。可以理解为：</span></span><br><span class="line"><span class="comment">//自己掌握着一个教室里已经关闭的灯，因为我没有开灯使用光线(即持有对象)，所以这盏灯的引用计数为0。并且我不能继续关灯(即释放对象)。但是我可以开灯使用这盏灯的光线(即持有对象)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数：%ld"</span>, [obj retainCount]);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数：%ld"</span>, [obj retainCount]);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">[obj release];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数：%ld"</span>, [obj retainCount]);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>虽然第一次输出为1，但是这个obj并非被自己所引用，因为如果我不调用[obj retain]方法，而直接调用[obj release]，会崩溃，原因是：过度释放。__NSArrayM object 0x100107340 overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug</p>
<hr>
<p>（4）autorelease方法：可以使取得的对象存在，但自己不持有，显然，使用便利构造器创建对象，其内部正是用了autorelease。它会是的对象在超出指定的生存范围时能够自动并准确地释放。</p>
<hr>
<p>（5）<code>__strong</code>：在ARC中，所有id类型和对象类型的所有权修饰符默认为<code>__strong</code>。__strong可以使自己持有非自己生成的对象，如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为obj是强引用，所以自己持有对象</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br></pre></td></tr></table></figure></p>
<p>上述代码等同于：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得非自己生成且非自己持有的对象</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="comment">// 现在持有了该对象</span></span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br></pre></td></tr></table></figure></p>
<hr>
<p>（6）<code>__weak</code>：提供弱引用，带有<code>__weak</code>标识符的对象不会持有该对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/第六篇、声明属性时的retain、copy、strong、assion到底做了什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/第六篇、声明属性时的retain、copy、strong、assion到底做了什么？/" itemprop="url">第六篇、声明属性时的retain、copy、strong、assion到底做了什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T00:00:00+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、先抛出一个问题：NSString属性为什么要用copy？用strong可以吗？"><a href="#1、先抛出一个问题：NSString属性为什么要用copy？用strong可以吗？" class="headerlink" title="1、先抛出一个问题：NSString属性为什么要用copy？用strong可以吗？"></a>1、先抛出一个问题：NSString属性为什么要用copy？用strong可以吗？</h3><p>照例先看例子：<br>例子(1)：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strongString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *copyedString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"123"</span>];</span><br><span class="line"><span class="keyword">self</span>.strongString = str;</span><br><span class="line"><span class="keyword">self</span>.copyedString = str;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str：%@，%#x，%p"</span>, str, str, &amp;str);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"strongString：%@，%#x，%p"</span>, _strongString, _strongString, &amp;_strongString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyedString：%@，%#x，%p"</span>, _copyedString, _copyedString, &amp;_copyedString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str：123，0x3332313，0x16fd0df28</span><br><span class="line">strongString：123，0x3332313，0x117f0a318</span><br><span class="line">copyedString：123，0x3332313，0x117f0a320</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>分析：可以看出，当str是不可变的时候，strongString和copyedString指向的内存和str指向的内存是一样的，相当于<code>浅拷贝</code>，如果str的值变化了，那么strongString和copyedString必定会跟着变化(一般而言，我们是不希望出现这个情况的)，但是由于str是不可变的，所以就不会出现那个情况。所以，这个时候，用strong和copy都是可以的。</p>
</blockquote>
<hr>
<p>例子(2)：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"123"</span>];</span><br><span class="line"><span class="keyword">self</span>.strongString = str;</span><br><span class="line"><span class="keyword">self</span>.copyedString = str;</span><br><span class="line"><span class="comment">// 修改str的值</span></span><br><span class="line">[str appendString:<span class="string">@"abc"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str：%@，%#x，%p"</span>, str, str, &amp;str);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"strongString：%@，%#x，%p"</span>, _strongString, _strongString, &amp;_strongString);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyedString：%@，%#x，%p"</span>, _copyedString, _copyedString, &amp;_copyedString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str：123abc，0x7426db00，0x16fdadf28</span><br><span class="line">strongString：123abc，0x7426db00，0x100209c58</span><br><span class="line">copyedString：123，0x3332313，0x100209c60</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>分析：可以看出，当str是不可变的时候，strongString所指向的内存和str所指向的内存是一样的<code>(浅拷贝)</code>；但是copyedString所指向的内存却和str所指向的内存不一样，也就是说当用self.copyedString = str赋值时，copyedString进行了<code>深拷贝</code>，对str这个指针也进行了拷贝，但是拷贝后的指针所存储的值还是abc。所以之后str的值发生变化时，strongString会跟着变化，但是copyedString还是保留原值。一般来说我们是希望原值改变后不会影响到到新值。</p>
</blockquote>
<p><strong>总结</strong>：<br>1、声明NSString类型的属性时，为了安全起见，最好用copy。<br>2、<code>浅拷贝</code>：简单的值拷贝，指针(地址)却没有拷贝，新值所指向的地址等于原值指向的地址，所以原值发生改变会影响到新值。<br><code>深拷贝</code>：值拷贝+指针(地址)拷贝，新值所指向的地址是一块新开辟的内存地址，所以原值发生改变不会影响到新值。<br><code>3、为什么str是不可变字符串的时候，self.copyedString = str是浅拷贝，而str是可变字符串的时候，self.copyedString = str是深拷贝拷贝？
我猜想这是苹果为了优化性能而故意为之吧。str是不可变字符串的时候，因为str不会发生改变，所以用浅拷贝。str是可变字符串的时候，因为str会发生改变，所以用深拷贝。
而显然，浅拷贝时，只是增加了引用计数，而深拷贝需要额外开辟内存空间。所以，为了更节省内存空间，才会这样做。</code></p>
<h3 id="2、由1来深入理解copy和strong内部的set方法做了什么。"><a href="#2、由1来深入理解copy和strong内部的set方法做了什么。" class="headerlink" title="2、由1来深入理解copy和strong内部的set方法做了什么。"></a>2、由1来深入理解copy和strong内部的set方法做了什么。</h3><p>虽然说copy是深拷贝，strong是浅拷贝，但是我们需要知道为什么会这样。显然是在self.copyedString = str赋值这一步跟self.strongString = str有所不同。也就是用这两个关键字修饰的属性，在set方法时所做的事情不同。</p>
<h3 id="3、不同修饰词的set方法。下面的release代码都是在MRC下。ARC下的release系统会帮我们做。"><a href="#3、不同修饰词的set方法。下面的release代码都是在MRC下。ARC下的release系统会帮我们做。" class="headerlink" title="3、不同修饰词的set方法。下面的release代码都是在MRC下。ARC下的release系统会帮我们做。"></a>3、不同修饰词的set方法。下面的release代码都是在MRC下。ARC下的release系统会帮我们做。</h3><p>(1) copy<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *copyedString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCopyedString:(<span class="built_in">NSString</span> *)newStr &#123;</span><br><span class="line"><span class="keyword">if</span> (_copyedString != newStr)&#123; <span class="comment">// 判断是否需要重新赋值</span></span><br><span class="line">[_copyedString release]; <span class="comment">// 释放旧引用，计数器-1</span></span><br><span class="line">_copyedString = [newStr <span class="keyword">copy</span>]; <span class="comment">// 重新赋值，使用copy</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：[newStr copy];所干的事情是：假设newStr的地址是p1，值是@”123”，那么[newStr copy]是先开辟一块新的内存空间p2(p2 ≠ p1)，值为@”123”，然后让_copyedString = p2。也就是_copyedString的值是新的内存空间地址p2，p2所存储的值为@”123”。这是完完全全的深拷贝。旧值的retainCount 不变。</p>
</blockquote>
<p>(2) retain<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSString</span> *retainedString;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setRetainedString:(<span class="built_in">NSString</span> *)newStr &#123;</span><br><span class="line"><span class="keyword">if</span> (_retainedString != newStr)&#123; <span class="comment">// 判断是否需要重新赋值</span></span><br><span class="line">[_retainedString release]; <span class="comment">// 释放旧引用，计数器-1</span></span><br><span class="line">_retainedString = [newStr <span class="keyword">retain</span>]; <span class="comment">// 重新赋值，retainCount +1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：[newStr retain];所干的事情是：假设newStr的地址是p1，值是@”123”，那么[newStr retain]是让_retainedString = p1。也就是_retainedString的值是内存空间地址p1，p1所存储的值为@”123”。这可以看做是一种浅拷贝。</p>
</blockquote>
<p>(3) strong (ARC下)</p>
<blockquote>
<p>strong相当于MRC下的retain，和浅拷贝有相同的效果，指针并没有被拷贝，被赋值的那个旧值的retainCount被+1。</p>
</blockquote>
<p>(4) assign 普通数据类型。数据存储在栈区，不需要手动去管理内存，系统自动管理<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">self</span>.num = a;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setNum:(<span class="keyword">int</span>)num &#123;</span><br><span class="line">_num = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：普通数据类型不涉及到地址，不涉及到内存管理，这里用assign直接赋值。</p>
</blockquote>
<p>(5) weak (ARC下)</p>
<blockquote>
<p>和assign很像，但是不会增加旧值的引用计数。当旧值被销毁后，新值的指针自动置为nil（发消息不会崩溃）不会成为野指针（野指针就是被指向的对象已经被销毁，但是指针却还指着那一块地址）。向野指针发送消息会崩溃。</p>
</blockquote>
<h3 id="4、自己做的测试"><a href="#4、自己做的测试" class="headerlink" title="4、自己做的测试"></a>4、自己做的测试</h3><p><a href="/source/summary6_sample_1.zip">代码下载</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/第五篇，浅复制和深复制的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/第五篇，浅复制和深复制的区别/" itemprop="url">第五篇、浅复制和深复制的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T00:00:00+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>具体看第六篇</p>
<p><code>浅拷贝</code>：简单的值拷贝，指针(地址)却没有拷贝，新值所指向的地址等于原值指向的地址，所以原值发生改变会影响到新值。<br>简单点说，就是新值只是增加了对原值指针的一个引用而已。</p>
<p><code>深拷贝</code>：值拷贝+指针(地址)拷贝，新值所指向的地址是一块新开辟的内存地址，所以原值发生改变不会影响到新值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/07/第四篇，Category-和-Extension/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李乾">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李乾的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/07/第四篇，Category-和-Extension/" itemprop="url">第四篇、Category 和 Extension</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-07T00:00:00+08:00">
                2017-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS面试总结及研究/" itemprop="url" rel="index">
                    <span itemprop="name">iOS面试总结及研究</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、Category"><a href="#一、Category" class="headerlink" title="一、Category"></a>一、Category</h3><blockquote>
<p>本文属于转载加笔记补充</p>
</blockquote>
<h4 id="1、原文出处"><a href="#1、原文出处" class="headerlink" title="1、原文出处"></a>1、原文出处</h4><p><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">原文链接</a><br><a href="http://tech.meituan.com/" target="_blank" rel="noopener">相关技术博客</a></p>
<h4 id="2、原文摘抄-笔记"><a href="#2、原文摘抄-笔记" class="headerlink" title="2、原文摘抄+笔记"></a>2、原文摘抄+笔记</h4><p><strong>category简介</strong></p>
<blockquote>
<p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景：</p>
<ul>
<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，(a)可以减少单个文件的体积 (b)可以&gt;把不同的功能组织到不同的category里 (c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li>
<li>声明私有方法</li>
</ul>
</blockquote>
<blockquote>
<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>
<ul>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
</blockquote>
<blockquote>
<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加&gt;任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>
</blockquote>
<p><strong>category和extension</strong></p>
<blockquote>
<ul>
<li>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。<br>extension在编译器决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统类如 NSString添加extension。</li>
<li>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。<br><code>疑问：那为什么就可以添加属性和方法呢？难道这不会破坏对象的内存布局？</code><br><code>答：</code></li>
</ul>
</blockquote>
<h4 id="（3）总结"><a href="#（3）总结" class="headerlink" title="（3）总结"></a>（3）总结</h4><hr>
<h3 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、Extension</h3><p>未完待续<br>几个链接：<br><a href="http://www.cocoachina.com/ios/20170406/19001.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20170406/19001.html</a><br><a href="http://www.jianshu.com/p/7d54b832c68b" target="_blank" rel="noopener">http://www.jianshu.com/p/7d54b832c68b</a><br><a href="http://blog.csdn.net/csdnliming147/article/details/53365159" target="_blank" rel="noopener">http://blog.csdn.net/csdnliming147/article/details/53365159</a><br><a href="http://www.cnblogs.com/Mike-zh/p/5143904.html" target="_blank" rel="noopener">http://www.cnblogs.com/Mike-zh/p/5143904.html</a></p>
<p>百度搜索：为什么category不能添加成员变量</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/avatar.jpeg"
                alt="李乾" />
            
              <p class="site-author-name" itemprop="name">李乾</p>
              <p class="site-description motion-element" itemprop="description">人生不止眼前的苟且 还有诗和远方</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiamoon" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李乾</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
